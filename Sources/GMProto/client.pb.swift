// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: client.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Client_ConversationActionStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknownActionStatus // = 0
  case delete // = 1
  case unblock // = 2
  case block // = 7
  case blockAndReport // = 8
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownActionStatus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownActionStatus
    case 1: self = .delete
    case 2: self = .unblock
    case 7: self = .block
    case 8: self = .blockAndReport
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownActionStatus: return 0
    case .delete: return 1
    case .unblock: return 2
    case .block: return 7
    case .blockAndReport: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Client_ConversationActionStatus] = [
    .unknownActionStatus,
    .delete,
    .unblock,
    .block,
    .blockAndReport,
  ]

}

public enum Client_ConversationMuteStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unmute // = 0
  case mute // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .unmute
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unmute
    case 1: self = .mute
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unmute: return 0
    case .mute: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Client_ConversationMuteStatus] = [
    .unmute,
    .mute,
  ]

}

public struct Client_NotifyDittoActivityRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// This is not actually a boolean: after logging out, field 2 has value 2, and field 3 has value 1.
  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_NotifyDittoActivityResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_ReceiveMessagesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var auth: Authentication_AuthMessage {
    get {return _auth ?? Authentication_AuthMessage()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var unknown: Client_ReceiveMessagesRequest.UnknownEmptyObject2 {
    get {return _unknown ?? Client_ReceiveMessagesRequest.UnknownEmptyObject2()}
    set {_unknown = newValue}
  }
  /// Returns true if `unknown` has been explicitly set.
  public var hasUnknown: Bool {return self._unknown != nil}
  /// Clears the value of `unknown`. Subsequent reads from it will return its default value.
  public mutating func clearUnknown() {self._unknown = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct UnknownEmptyObject1: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct UnknownEmptyObject2: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknown: Client_ReceiveMessagesRequest.UnknownEmptyObject1 {
      get {return _unknown ?? Client_ReceiveMessagesRequest.UnknownEmptyObject1()}
      set {_unknown = newValue}
    }
    /// Returns true if `unknown` has been explicitly set.
    public var hasUnknown: Bool {return self._unknown != nil}
    /// Clears the value of `unknown`. Subsequent reads from it will return its default value.
    public mutating func clearUnknown() {self._unknown = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _unknown: Client_ReceiveMessagesRequest.UnknownEmptyObject1? = nil
  }

  public init() {}

  fileprivate var _auth: Authentication_AuthMessage? = nil
  fileprivate var _unknown: Client_ReceiveMessagesRequest.UnknownEmptyObject2? = nil
}

public struct Client_MessageReadRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String = String()

  public var messageID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_AckMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var authData: Authentication_AuthMessage {
    get {return _authData ?? Authentication_AuthMessage()}
    set {_authData = newValue}
  }
  /// Returns true if `authData` has been explicitly set.
  public var hasAuthData: Bool {return self._authData != nil}
  /// Clears the value of `authData`. Subsequent reads from it will return its default value.
  public mutating func clearAuthData() {self._authData = nil}

  public var emptyArr: Util_EmptyArr {
    get {return _emptyArr ?? Util_EmptyArr()}
    set {_emptyArr = newValue}
  }
  /// Returns true if `emptyArr` has been explicitly set.
  public var hasEmptyArr: Bool {return self._emptyArr != nil}
  /// Clears the value of `emptyArr`. Subsequent reads from it will return its default value.
  public mutating func clearEmptyArr() {self._emptyArr = nil}

  public var acks: [Client_AckMessageRequest.Message] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Message: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var requestID: String = String()

    public var device: Authentication_Device {
      get {return _device ?? Authentication_Device()}
      set {_device = newValue}
    }
    /// Returns true if `device` has been explicitly set.
    public var hasDevice: Bool {return self._device != nil}
    /// Clears the value of `device`. Subsequent reads from it will return its default value.
    public mutating func clearDevice() {self._device = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _device: Authentication_Device? = nil
  }

  public init() {}

  fileprivate var _authData: Authentication_AuthMessage? = nil
  fileprivate var _emptyArr: Util_EmptyArr? = nil
}

public struct Client_DownloadAttachmentRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var info: Client_AttachmentInfo {
    get {return _info ?? Client_AttachmentInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  public var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  public mutating func clearInfo() {self._info = nil}

  public var authData: Authentication_AuthMessage {
    get {return _authData ?? Authentication_AuthMessage()}
    set {_authData = newValue}
  }
  /// Returns true if `authData` has been explicitly set.
  public var hasAuthData: Bool {return self._authData != nil}
  /// Clears the value of `authData`. Subsequent reads from it will return its default value.
  public mutating func clearAuthData() {self._authData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _info: Client_AttachmentInfo? = nil
  fileprivate var _authData: Authentication_AuthMessage? = nil
}

public struct Client_AttachmentInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var attachmentID: String = String()

  public var encrypted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_StartMediaUploadRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var attachmentType: Int64 = 0

  public var authData: Authentication_AuthMessage {
    get {return _authData ?? Authentication_AuthMessage()}
    set {_authData = newValue}
  }
  /// Returns true if `authData` has been explicitly set.
  public var hasAuthData: Bool {return self._authData != nil}
  /// Clears the value of `authData`. Subsequent reads from it will return its default value.
  public mutating func clearAuthData() {self._authData = nil}

  public var mobile: Authentication_Device {
    get {return _mobile ?? Authentication_Device()}
    set {_mobile = newValue}
  }
  /// Returns true if `mobile` has been explicitly set.
  public var hasMobile: Bool {return self._mobile != nil}
  /// Clears the value of `mobile`. Subsequent reads from it will return its default value.
  public mutating func clearMobile() {self._mobile = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authData: Authentication_AuthMessage? = nil
  fileprivate var _mobile: Authentication_Device? = nil
}

public struct Client_UploadMediaResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var media: Client_UploadedMedia {
    get {return _media ?? Client_UploadedMedia()}
    set {_media = newValue}
  }
  /// Returns true if `media` has been explicitly set.
  public var hasMedia: Bool {return self._media != nil}
  /// Clears the value of `media`. Subsequent reads from it will return its default value.
  public mutating func clearMedia() {self._media = nil}

  public var message: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _media: Client_UploadedMedia? = nil
}

public struct Client_UploadedMedia: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mediaID: String = String()

  public var mediaNumber: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_GetThumbnailRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var identifiers: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_GetThumbnailResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var thumbnail: [Client_GetThumbnailResponse.Thumbnail] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Thumbnail: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// ID depends on request, it's always the same as the input.
    public var identifier: String = String()

    public var data: Client_ThumbnailData {
      get {return _data ?? Client_ThumbnailData()}
      set {_data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    public var hasData: Bool {return self._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    public mutating func clearData() {self._data = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _data: Client_ThumbnailData? = nil
  }

  public init() {}
}

public struct Client_ThumbnailData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 2 -> 13: 16 mysterious bytes
  public var imageBuffer: Data = Data()

  public var someInt: Int32 = 0

  public var dimensions: Conversations_Dimensions {
    get {return _dimensions ?? Conversations_Dimensions()}
    set {_dimensions = newValue}
  }
  /// Returns true if `dimensions` has been explicitly set.
  public var hasDimensions: Bool {return self._dimensions != nil}
  /// Clears the value of `dimensions`. Subsequent reads from it will return its default value.
  public mutating func clearDimensions() {self._dimensions = nil}

  public var mysteriousData: Client_ThumbnailData.MysteriousData {
    get {return _mysteriousData ?? Client_ThumbnailData.MysteriousData()}
    set {_mysteriousData = newValue}
  }
  /// Returns true if `mysteriousData` has been explicitly set.
  public var hasMysteriousData: Bool {return self._mysteriousData != nil}
  /// Clears the value of `mysteriousData`. Subsequent reads from it will return its default value.
  public mutating func clearMysteriousData() {self._mysteriousData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct MysteriousData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var maybeAhash: UInt64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _dimensions: Conversations_Dimensions? = nil
  fileprivate var _mysteriousData: Client_ThumbnailData.MysteriousData? = nil
}

public struct Client_Cursor: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lastItemID: String = String()

  public var lastItemTimestamp: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_ListMessagesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String = String()

  public var count: Int64 = 0

  public var cursor: Client_Cursor {
    get {return _cursor ?? Client_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cursor: Client_Cursor? = nil
}

public struct Client_ListMessagesResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messages: [Conversations_Message] = []

  public var someBytes: Data = Data()

  public var totalMessages: Int64 = 0

  public var cursor: Client_Cursor {
    get {return _cursor ?? Client_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cursor: Client_Cursor? = nil
}

public struct Client_ListContactsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// = 1
  public var i1: Int32 = 0

  /// = 350
  public var i2: Int32 = 0

  /// = 50
  public var i3: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_ListTopContactsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var count: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_ListContactsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contacts: [Conversations_Contact] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_ListTopContactsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var contacts: [Conversations_Contact] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_ListConversationsRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var count: Int64 = 0

  public var folder: Client_ListConversationsRequest.Folder = .unknown

  public var cursor: Client_Cursor {
    get {return _cursor ?? Client_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Folder: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unknown // = 0
    case inbox // = 1
    case archive // = 2
    case spamBlocked // = 5
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .inbox
      case 2: self = .archive
      case 5: self = .spamBlocked
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .inbox: return 1
      case .archive: return 2
      case .spamBlocked: return 5
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Client_ListConversationsRequest.Folder] = [
      .unknown,
      .inbox,
      .archive,
      .spamBlocked,
    ]

  }

  public init() {}

  fileprivate var _cursor: Client_Cursor? = nil
}

public struct Client_ListConversationsResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversations: [Conversations_Conversation] = []

  public var cursorBytes: Data {
    get {return _cursorBytes ?? Data()}
    set {_cursorBytes = newValue}
  }
  /// Returns true if `cursorBytes` has been explicitly set.
  public var hasCursorBytes: Bool {return self._cursorBytes != nil}
  /// Clears the value of `cursorBytes`. Subsequent reads from it will return its default value.
  public mutating func clearCursorBytes() {self._cursorBytes = nil}

  public var cursor: Client_Cursor {
    get {return _cursor ?? Client_Cursor()}
    set {_cursor = newValue}
  }
  /// Returns true if `cursor` has been explicitly set.
  public var hasCursor: Bool {return self._cursor != nil}
  /// Clears the value of `cursor`. Subsequent reads from it will return its default value.
  public mutating func clearCursor() {self._cursor = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _cursorBytes: Data? = nil
  fileprivate var _cursor: Client_Cursor? = nil
}

public struct Client_GetOrCreateConversationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var numbers: [Conversations_ContactNumber] = []

  public var rcsgroupName: String {
    get {return _rcsgroupName ?? String()}
    set {_rcsgroupName = newValue}
  }
  /// Returns true if `rcsgroupName` has been explicitly set.
  public var hasRcsgroupName: Bool {return self._rcsgroupName != nil}
  /// Clears the value of `rcsgroupName`. Subsequent reads from it will return its default value.
  public mutating func clearRcsgroupName() {self._rcsgroupName = nil}

  public var createRcsgroup: Bool {
    get {return _createRcsgroup ?? false}
    set {_createRcsgroup = newValue}
  }
  /// Returns true if `createRcsgroup` has been explicitly set.
  public var hasCreateRcsgroup: Bool {return self._createRcsgroup != nil}
  /// Clears the value of `createRcsgroup`. Subsequent reads from it will return its default value.
  public mutating func clearCreateRcsgroup() {self._createRcsgroup = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _rcsgroupName: String? = nil
  fileprivate var _createRcsgroup: Bool? = nil
}

public struct Client_GetOrCreateConversationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversation: Conversations_Conversation {
    get {return _conversation ?? Conversations_Conversation()}
    set {_conversation = newValue}
  }
  /// Returns true if `conversation` has been explicitly set.
  public var hasConversation: Bool {return self._conversation != nil}
  /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
  public mutating func clearConversation() {self._conversation = nil}

  public var status: Client_GetOrCreateConversationResponse.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unknown // = 0
    case success // = 1
    case createRcs // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 3: self = .createRcs
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .createRcs: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Client_GetOrCreateConversationResponse.Status] = [
      .unknown,
      .success,
      .createRcs,
    ]

  }

  public init() {}

  fileprivate var _conversation: Conversations_Conversation? = nil
}

public struct Client_DeleteMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_DeleteMessageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_UpdateConversationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var action: Client_ConversationActionStatus = .unknownActionStatus

  public var conversationID: String = String()

  public var action5: Client_ConversationAction5 {
    get {return _action5 ?? Client_ConversationAction5()}
    set {_action5 = newValue}
  }
  /// Returns true if `action5` has been explicitly set.
  public var hasAction5: Bool {return self._action5 != nil}
  /// Clears the value of `action5`. Subsequent reads from it will return its default value.
  public mutating func clearAction5() {self._action5 = nil}

  public var data: Client_UpdateConversationRequest.OneOf_Data? = nil

  public var deleteData: Client_DeleteConversationData {
    get {
      if case .deleteData(let v)? = data {return v}
      return Client_DeleteConversationData()
    }
    set {data = .deleteData(newValue)}
  }

  public var updateData: Client_UpdateConversationData {
    get {
      if case .updateData(let v)? = data {return v}
      return Client_UpdateConversationData()
    }
    set {data = .updateData(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable, Sendable {
    case deleteData(Client_DeleteConversationData)
    case updateData(Client_UpdateConversationData)

  }

  public init() {}

  fileprivate var _action5: Client_ConversationAction5? = nil
}

public struct Client_ConversationAction5: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field2: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_DeleteConversationData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String = String()

  public var phone: String {
    get {return _phone ?? String()}
    set {_phone = newValue}
  }
  /// Returns true if `phone` has been explicitly set.
  public var hasPhone: Bool {return self._phone != nil}
  /// Clears the value of `phone`. Subsequent reads from it will return its default value.
  public mutating func clearPhone() {self._phone = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _phone: String? = nil
}

public struct Client_UpdateConversationData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String = String()

  public var data: Client_UpdateConversationData.OneOf_Data? = nil

  public var status: Conversations_ConversationStatus {
    get {
      if case .status(let v)? = data {return v}
      return .unknownConversationStatus
    }
    set {data = .status(newValue)}
  }

  public var mute: Client_ConversationMuteStatus {
    get {
      if case .mute(let v)? = data {return v}
      return .unmute
    }
    set {data = .mute(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable, Sendable {
    case status(Conversations_ConversationStatus)
    case mute(Client_ConversationMuteStatus)

  }

  public init() {}
}

public struct Client_UpdateConversationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///3 {
  ///1 {
  ///1 {
  ///3: "11"
  ///}
  ///13: 2
  ///}
  ///3: 1
  ///}
  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_GetConversationTypeRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_GetConversationTypeResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String = String()

  public var type: Int32 = 0

  public var bool1: Bool = false

  public var number2: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_GetConversationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_GetConversationResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversation: Conversations_Conversation {
    get {return _conversation ?? Conversations_Conversation()}
    set {_conversation = newValue}
  }
  /// Returns true if `conversation` has been explicitly set.
  public var hasConversation: Bool {return self._conversation != nil}
  /// Clears the value of `conversation`. Subsequent reads from it will return its default value.
  public mutating func clearConversation() {self._conversation = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _conversation: Conversations_Conversation? = nil
}

public struct Client_OpenConversationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_PrepareOpenConversationRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// only seen value 1
  public var field2: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_IsBugleDefaultResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_SendMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String = String()

  public var messagePayload: Client_MessagePayload {
    get {return _messagePayload ?? Client_MessagePayload()}
    set {_messagePayload = newValue}
  }
  /// Returns true if `messagePayload` has been explicitly set.
  public var hasMessagePayload: Bool {return self._messagePayload != nil}
  /// Clears the value of `messagePayload`. Subsequent reads from it will return its default value.
  public mutating func clearMessagePayload() {self._messagePayload = nil}

  public var simpayload: Settings_SIMPayload {
    get {return _simpayload ?? Settings_SIMPayload()}
    set {_simpayload = newValue}
  }
  /// Returns true if `simpayload` has been explicitly set.
  public var hasSimpayload: Bool {return self._simpayload != nil}
  /// Clears the value of `simpayload`. Subsequent reads from it will return its default value.
  public mutating func clearSimpayload() {self._simpayload = nil}

  public var tmpID: String = String()

  public var forceRcs: Bool = false

  public var reply: Client_ReplyPayload {
    get {return _reply ?? Client_ReplyPayload()}
    set {_reply = newValue}
  }
  /// Returns true if `reply` has been explicitly set.
  public var hasReply: Bool {return self._reply != nil}
  /// Clears the value of `reply`. Subsequent reads from it will return its default value.
  public mutating func clearReply() {self._reply = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _messagePayload: Client_MessagePayload? = nil
  fileprivate var _simpayload: Settings_SIMPayload? = nil
  fileprivate var _reply: Client_ReplyPayload? = nil
}

public struct Client_ReplyPayload: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_MessagePayload: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tmpID: String = String()

  public var messagePayloadContent: Client_MessagePayloadContent {
    get {return _messagePayloadContent ?? Client_MessagePayloadContent()}
    set {_messagePayloadContent = newValue}
  }
  /// Returns true if `messagePayloadContent` has been explicitly set.
  public var hasMessagePayloadContent: Bool {return self._messagePayloadContent != nil}
  /// Clears the value of `messagePayloadContent`. Subsequent reads from it will return its default value.
  public mutating func clearMessagePayloadContent() {self._messagePayloadContent = nil}

  public var conversationID: String = String()

  public var participantID: String = String()

  public var messageInfo: [Conversations_MessageInfo] = []

  public var tmpID2: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _messagePayloadContent: Client_MessagePayloadContent? = nil
}

public struct Client_MessagePayloadContent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageContent: Conversations_MessageContent {
    get {return _messageContent ?? Conversations_MessageContent()}
    set {_messageContent = newValue}
  }
  /// Returns true if `messageContent` has been explicitly set.
  public var hasMessageContent: Bool {return self._messageContent != nil}
  /// Clears the value of `messageContent`. Subsequent reads from it will return its default value.
  public mutating func clearMessageContent() {self._messageContent = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _messageContent: Conversations_MessageContent? = nil
}

public struct Client_SendMessageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var googleAccountSwitch: Events_AccountChangeOrSomethingEvent {
    get {return _googleAccountSwitch ?? Events_AccountChangeOrSomethingEvent()}
    set {_googleAccountSwitch = newValue}
  }
  /// Returns true if `googleAccountSwitch` has been explicitly set.
  public var hasGoogleAccountSwitch: Bool {return self._googleAccountSwitch != nil}
  /// Clears the value of `googleAccountSwitch`. Subsequent reads from it will return its default value.
  public mutating func clearGoogleAccountSwitch() {self._googleAccountSwitch = nil}

  public var status: Client_SendMessageResponse.Status = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Status: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unknown // = 0
    case success // = 1
    case failure2 // = 2
    case failure3 // = 3

    /// not default sms app?
    case failure4 // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknown
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .failure2
      case 3: self = .failure3
      case 4: self = .failure4
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .failure2: return 2
      case .failure3: return 3
      case .failure4: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Client_SendMessageResponse.Status] = [
      .unknown,
      .success,
      .failure2,
      .failure3,
      .failure4,
    ]

  }

  public init() {}

  fileprivate var _googleAccountSwitch: Events_AccountChangeOrSomethingEvent? = nil
}

public struct Client_SendReactionRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: String {
    get {return _storage._messageID}
    set {_uniqueStorage()._messageID = newValue}
  }

  public var reactionData: Conversations_ReactionData {
    get {return _storage._reactionData ?? Conversations_ReactionData()}
    set {_uniqueStorage()._reactionData = newValue}
  }
  /// Returns true if `reactionData` has been explicitly set.
  public var hasReactionData: Bool {return _storage._reactionData != nil}
  /// Clears the value of `reactionData`. Subsequent reads from it will return its default value.
  public mutating func clearReactionData() {_uniqueStorage()._reactionData = nil}

  public var action: Client_SendReactionRequest.Action {
    get {return _storage._action}
    set {_uniqueStorage()._action = newValue}
  }

  public var simpayload: Settings_SIMPayload {
    get {return _storage._simpayload ?? Settings_SIMPayload()}
    set {_uniqueStorage()._simpayload = newValue}
  }
  /// Returns true if `simpayload` has been explicitly set.
  public var hasSimpayload: Bool {return _storage._simpayload != nil}
  /// Clears the value of `simpayload`. Subsequent reads from it will return its default value.
  public mutating func clearSimpayload() {_uniqueStorage()._simpayload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum Action: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unspecified // = 0
    case add // = 1
    case remove // = 2
    case `switch` // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .unspecified
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unspecified
      case 1: self = .add
      case 2: self = .remove
      case 3: self = .switch
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unspecified: return 0
      case .add: return 1
      case .remove: return 2
      case .switch: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Client_SendReactionRequest.Action] = [
      .unspecified,
      .add,
      .remove,
      .switch,
    ]

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Client_SendReactionResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_ResendMessageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_TypingUpdateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Client_TypingUpdateRequest.DataMessage {
    get {return _data ?? Client_TypingUpdateRequest.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var simpayload: Settings_SIMPayload {
    get {return _simpayload ?? Settings_SIMPayload()}
    set {_simpayload = newValue}
  }
  /// Returns true if `simpayload` has been explicitly set.
  public var hasSimpayload: Bool {return self._simpayload != nil}
  /// Clears the value of `simpayload`. Subsequent reads from it will return its default value.
  public mutating func clearSimpayload() {self._simpayload = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var conversationID: String = String()

    public var typing: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _data: Client_TypingUpdateRequest.DataMessage? = nil
  fileprivate var _simpayload: Settings_SIMPayload? = nil
}

public struct Client_SettingsUpdateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pushSettings: Client_SettingsUpdateRequest.PushSettings {
    get {return _pushSettings ?? Client_SettingsUpdateRequest.PushSettings()}
    set {_pushSettings = newValue}
  }
  /// Returns true if `pushSettings` has been explicitly set.
  public var hasPushSettings: Bool {return self._pushSettings != nil}
  /// Clears the value of `pushSettings`. Subsequent reads from it will return its default value.
  public mutating func clearPushSettings() {self._pushSettings = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct PushSettings: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var enabled: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _pushSettings: Client_SettingsUpdateRequest.PushSettings? = nil
}

public struct Client_GetFullSizeImageRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: String = String()

  public var actionMessageID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Client_GetFullSizeImageResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "client"

extension Client_ConversationActionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN_ACTION_STATUS\0\u{1}DELETE\0\u{1}UNBLOCK\0\u{2}\u{5}BLOCK\0\u{1}BLOCK_AND_REPORT\0")
}

extension Client_ConversationMuteStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNMUTE\0\u{1}MUTE\0")
}

extension Client_NotifyDittoActivityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotifyDittoActivityRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_NotifyDittoActivityRequest, rhs: Client_NotifyDittoActivityRequest) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_NotifyDittoActivityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NotifyDittoActivityResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_NotifyDittoActivityResponse, rhs: Client_NotifyDittoActivityResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ReceiveMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReceiveMessagesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}auth\0\u{2}\u{3}unknown\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._unknown) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._unknown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ReceiveMessagesRequest, rhs: Client_ReceiveMessagesRequest) -> Bool {
    if lhs._auth != rhs._auth {return false}
    if lhs._unknown != rhs._unknown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ReceiveMessagesRequest.UnknownEmptyObject1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Client_ReceiveMessagesRequest.protoMessageName + ".UnknownEmptyObject1"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ReceiveMessagesRequest.UnknownEmptyObject1, rhs: Client_ReceiveMessagesRequest.UnknownEmptyObject1) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ReceiveMessagesRequest.UnknownEmptyObject2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Client_ReceiveMessagesRequest.protoMessageName + ".UnknownEmptyObject2"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}unknown\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._unknown) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._unknown {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ReceiveMessagesRequest.UnknownEmptyObject2, rhs: Client_ReceiveMessagesRequest.UnknownEmptyObject2) -> Bool {
    if lhs._unknown != rhs._unknown {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_MessageReadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageReadRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}conversationID\0\u{1}messageID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_MessageReadRequest, rhs: Client_MessageReadRequest) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_AckMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AckMessageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}authData\0\u{1}emptyArr\0\u{2}\u{2}acks\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authData) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._emptyArr) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.acks) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._emptyArr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.acks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.acks, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_AckMessageRequest, rhs: Client_AckMessageRequest) -> Bool {
    if lhs._authData != rhs._authData {return false}
    if lhs._emptyArr != rhs._emptyArr {return false}
    if lhs.acks != rhs.acks {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_AckMessageRequest.Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Client_AckMessageRequest.protoMessageName + ".Message"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requestID\0\u{1}device\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_AckMessageRequest.Message, rhs: Client_AckMessageRequest.Message) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_DownloadAttachmentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DownloadAttachmentRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}info\0\u{1}authData\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._authData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_DownloadAttachmentRequest, rhs: Client_DownloadAttachmentRequest) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs._authData != rhs._authData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_AttachmentInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AttachmentInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}attachmentID\0\u{1}encrypted\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.attachmentID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.encrypted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.attachmentID.isEmpty {
      try visitor.visitSingularStringField(value: self.attachmentID, fieldNumber: 1)
    }
    if self.encrypted != false {
      try visitor.visitSingularBoolField(value: self.encrypted, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_AttachmentInfo, rhs: Client_AttachmentInfo) -> Bool {
    if lhs.attachmentID != rhs.attachmentID {return false}
    if lhs.encrypted != rhs.encrypted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_StartMediaUploadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartMediaUploadRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}attachmentType\0\u{1}authData\0\u{1}mobile\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.attachmentType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._authData) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._mobile) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.attachmentType != 0 {
      try visitor.visitSingularInt64Field(value: self.attachmentType, fieldNumber: 1)
    }
    try { if let v = self._authData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mobile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_StartMediaUploadRequest, rhs: Client_StartMediaUploadRequest) -> Bool {
    if lhs.attachmentType != rhs.attachmentType {return false}
    if lhs._authData != rhs._authData {return false}
    if lhs._mobile != rhs._mobile {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_UploadMediaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadMediaResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}media\0\u{1}message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._media) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._media {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_UploadMediaResponse, rhs: Client_UploadMediaResponse) -> Bool {
    if lhs._media != rhs._media {return false}
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_UploadedMedia: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UploadedMedia"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mediaID\0\u{1}mediaNumber\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mediaID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.mediaNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.mediaID.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaID, fieldNumber: 1)
    }
    if self.mediaNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.mediaNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_UploadedMedia, rhs: Client_UploadedMedia) -> Bool {
    if lhs.mediaID != rhs.mediaID {return false}
    if lhs.mediaNumber != rhs.mediaNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_GetThumbnailRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetThumbnailRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifiers\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.identifiers) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.identifiers.isEmpty {
      try visitor.visitRepeatedStringField(value: self.identifiers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_GetThumbnailRequest, rhs: Client_GetThumbnailRequest) -> Bool {
    if lhs.identifiers != rhs.identifiers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_GetThumbnailResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetThumbnailResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}thumbnail\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.thumbnail) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.thumbnail.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.thumbnail, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_GetThumbnailResponse, rhs: Client_GetThumbnailResponse) -> Bool {
    if lhs.thumbnail != rhs.thumbnail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_GetThumbnailResponse.Thumbnail: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Client_GetThumbnailResponse.protoMessageName + ".Thumbnail"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}identifier\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.identifier) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.identifier.isEmpty {
      try visitor.visitSingularStringField(value: self.identifier, fieldNumber: 1)
    }
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_GetThumbnailResponse.Thumbnail, rhs: Client_GetThumbnailResponse.Thumbnail) -> Bool {
    if lhs.identifier != rhs.identifier {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ThumbnailData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ThumbnailData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}mysteriousData\0\u{1}imageBuffer\0\u{1}someInt\0\u{1}dimensions\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._mysteriousData) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.imageBuffer) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.someInt) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._dimensions) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mysteriousData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.imageBuffer.isEmpty {
      try visitor.visitSingularBytesField(value: self.imageBuffer, fieldNumber: 3)
    }
    if self.someInt != 0 {
      try visitor.visitSingularInt32Field(value: self.someInt, fieldNumber: 4)
    }
    try { if let v = self._dimensions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ThumbnailData, rhs: Client_ThumbnailData) -> Bool {
    if lhs.imageBuffer != rhs.imageBuffer {return false}
    if lhs.someInt != rhs.someInt {return false}
    if lhs._dimensions != rhs._dimensions {return false}
    if lhs._mysteriousData != rhs._mysteriousData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ThumbnailData.MysteriousData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Client_ThumbnailData.protoMessageName + ".MysteriousData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{d}maybeAHash\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 13: try { try decoder.decodeSingularFixed64Field(value: &self.maybeAhash) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maybeAhash != 0 {
      try visitor.visitSingularFixed64Field(value: self.maybeAhash, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ThumbnailData.MysteriousData, rhs: Client_ThumbnailData.MysteriousData) -> Bool {
    if lhs.maybeAhash != rhs.maybeAhash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_Cursor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Cursor"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}lastItemID\0\u{1}lastItemTimestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.lastItemID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.lastItemTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.lastItemID.isEmpty {
      try visitor.visitSingularStringField(value: self.lastItemID, fieldNumber: 1)
    }
    if self.lastItemTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.lastItemTimestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_Cursor, rhs: Client_Cursor) -> Bool {
    if lhs.lastItemID != rhs.lastItemID {return false}
    if lhs.lastItemTimestamp != rhs.lastItemTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ListMessagesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListMessagesRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}conversationID\0\u{1}count\0\u{2}\u{2}cursor\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 3)
    }
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ListMessagesRequest, rhs: Client_ListMessagesRequest) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.count != rhs.count {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ListMessagesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListMessagesResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}messages\0\u{1}someBytes\0\u{1}totalMessages\0\u{1}cursor\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.messages) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.someBytes) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.totalMessages) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messages.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messages, fieldNumber: 2)
    }
    if !self.someBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.someBytes, fieldNumber: 3)
    }
    if self.totalMessages != 0 {
      try visitor.visitSingularInt64Field(value: self.totalMessages, fieldNumber: 4)
    }
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ListMessagesResponse, rhs: Client_ListMessagesResponse) -> Bool {
    if lhs.messages != rhs.messages {return false}
    if lhs.someBytes != rhs.someBytes {return false}
    if lhs.totalMessages != rhs.totalMessages {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ListContactsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListContactsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{5}i1\0\u{1}i2\0\u{1}i3\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.i1) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.i2) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.i3) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.i1 != 0 {
      try visitor.visitSingularInt32Field(value: self.i1, fieldNumber: 5)
    }
    if self.i2 != 0 {
      try visitor.visitSingularInt32Field(value: self.i2, fieldNumber: 6)
    }
    if self.i3 != 0 {
      try visitor.visitSingularInt32Field(value: self.i3, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ListContactsRequest, rhs: Client_ListContactsRequest) -> Bool {
    if lhs.i1 != rhs.i1 {return false}
    if lhs.i2 != rhs.i2 {return false}
    if lhs.i3 != rhs.i3 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ListTopContactsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTopContactsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.count != 0 {
      try visitor.visitSingularInt32Field(value: self.count, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ListTopContactsRequest, rhs: Client_ListTopContactsRequest) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ListContactsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListContactsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}contacts\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.contacts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contacts, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ListContactsResponse, rhs: Client_ListContactsResponse) -> Bool {
    if lhs.contacts != rhs.contacts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ListTopContactsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListTopContactsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}contacts\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.contacts) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.contacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contacts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ListTopContactsResponse, rhs: Client_ListTopContactsResponse) -> Bool {
    if lhs.contacts != rhs.contacts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ListConversationsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConversationsRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}count\0\u{2}\u{2}folder\0\u{1}cursor\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.count) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.folder) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.count != 0 {
      try visitor.visitSingularInt64Field(value: self.count, fieldNumber: 2)
    }
    if self.folder != .unknown {
      try visitor.visitSingularEnumField(value: self.folder, fieldNumber: 4)
    }
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ListConversationsRequest, rhs: Client_ListConversationsRequest) -> Bool {
    if lhs.count != rhs.count {return false}
    if lhs.folder != rhs.folder {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ListConversationsRequest.Folder: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN\0\u{1}INBOX\0\u{1}ARCHIVE\0\u{2}\u{3}SPAM_BLOCKED\0")
}

extension Client_ListConversationsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ListConversationsResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}conversations\0\u{1}cursorBytes\0\u{2}\u{2}cursor\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.conversations) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._cursorBytes) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._cursor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conversations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conversations, fieldNumber: 2)
    }
    try { if let v = self._cursorBytes {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._cursor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ListConversationsResponse, rhs: Client_ListConversationsResponse) -> Bool {
    if lhs.conversations != rhs.conversations {return false}
    if lhs._cursorBytes != rhs._cursorBytes {return false}
    if lhs._cursor != rhs._cursor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_GetOrCreateConversationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrCreateConversationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}numbers\0\u{1}RCSGroupName\0\u{1}createRCSGroup\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.numbers) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._rcsgroupName) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._createRcsgroup) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.numbers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.numbers, fieldNumber: 2)
    }
    try { if let v = self._rcsgroupName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._createRcsgroup {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_GetOrCreateConversationRequest, rhs: Client_GetOrCreateConversationRequest) -> Bool {
    if lhs.numbers != rhs.numbers {return false}
    if lhs._rcsgroupName != rhs._rcsgroupName {return false}
    if lhs._createRcsgroup != rhs._createRcsgroup {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_GetOrCreateConversationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetOrCreateConversationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}conversation\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_GetOrCreateConversationResponse, rhs: Client_GetOrCreateConversationResponse) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_GetOrCreateConversationResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN\0\u{1}SUCCESS\0\u{2}\u{2}CREATE_RCS\0")
}

extension Client_DeleteMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteMessageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}messageID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_DeleteMessageRequest, rhs: Client_DeleteMessageRequest) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_DeleteMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteMessageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_DeleteMessageResponse, rhs: Client_DeleteMessageResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_UpdateConversationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateConversationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}updateData\0\u{1}action\0\u{1}conversationID\0\u{2}\u{2}action5\0\u{1}deleteData\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Client_UpdateConversationData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .updateData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .updateData(v)
        }
      }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._action5) }()
      case 6: try {
        var v: Client_DeleteConversationData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .deleteData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .deleteData(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .updateData(let v)? = self.data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.action != .unknownActionStatus {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 3)
    }
    try { if let v = self._action5 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if case .deleteData(let v)? = self.data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_UpdateConversationRequest, rhs: Client_UpdateConversationRequest) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs._action5 != rhs._action5 {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ConversationAction5: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConversationAction5"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}field2\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularBoolField(value: &self.field2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.field2 != false {
      try visitor.visitSingularBoolField(value: self.field2, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ConversationAction5, rhs: Client_ConversationAction5) -> Bool {
    if lhs.field2 != rhs.field2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_DeleteConversationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteConversationData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conversationID\0\u{2}\u{2}phone\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._phone) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    try { if let v = self._phone {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_DeleteConversationData, rhs: Client_DeleteConversationData) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs._phone != rhs._phone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_UpdateConversationData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateConversationData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conversationID\0\u{2}\u{6}mute\0\u{2}\u{5}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 7: try {
        var v: Client_ConversationMuteStatus?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .mute(v)
        }
      }()
      case 12: try {
        var v: Conversations_ConversationStatus?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .status(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    switch self.data {
    case .mute?: try {
      guard case .mute(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 7)
    }()
    case .status?: try {
      guard case .status(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_UpdateConversationData, rhs: Client_UpdateConversationData) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_UpdateConversationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateConversationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_UpdateConversationResponse, rhs: Client_UpdateConversationResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_GetConversationTypeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConversationTypeRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}conversationID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_GetConversationTypeRequest, rhs: Client_GetConversationTypeRequest) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_GetConversationTypeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConversationTypeResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}conversationID\0\u{1}type\0\u{2}\u{2}bool1\0\u{1}number2\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.type) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.bool1) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.number2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    if self.type != 0 {
      try visitor.visitSingularInt32Field(value: self.type, fieldNumber: 3)
    }
    if self.bool1 != false {
      try visitor.visitSingularBoolField(value: self.bool1, fieldNumber: 5)
    }
    if self.number2 != 0 {
      try visitor.visitSingularInt32Field(value: self.number2, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_GetConversationTypeResponse, rhs: Client_GetConversationTypeResponse) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.bool1 != rhs.bool1 {return false}
    if lhs.number2 != rhs.number2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_GetConversationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConversationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conversationID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_GetConversationRequest, rhs: Client_GetConversationRequest) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_GetConversationResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetConversationResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conversation\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._conversation) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._conversation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_GetConversationResponse, rhs: Client_GetConversationResponse) -> Bool {
    if lhs._conversation != rhs._conversation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_OpenConversationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OpenConversationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}conversationID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_OpenConversationRequest, rhs: Client_OpenConversationRequest) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_PrepareOpenConversationRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PrepareOpenConversationRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}field2\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.field2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.field2 != 0 {
      try visitor.visitSingularInt64Field(value: self.field2, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_PrepareOpenConversationRequest, rhs: Client_PrepareOpenConversationRequest) -> Bool {
    if lhs.field2 != rhs.field2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_IsBugleDefaultResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IsBugleDefaultResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_IsBugleDefaultResponse, rhs: Client_IsBugleDefaultResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_SendMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendMessageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}conversationID\0\u{1}messagePayload\0\u{1}SIMPayload\0\u{1}tmpID\0\u{1}forceRCS\0\u{2}\u{2}reply\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._messagePayload) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._simpayload) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.tmpID) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.forceRcs) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._reply) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    try { if let v = self._messagePayload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._simpayload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.tmpID.isEmpty {
      try visitor.visitSingularStringField(value: self.tmpID, fieldNumber: 5)
    }
    if self.forceRcs != false {
      try visitor.visitSingularBoolField(value: self.forceRcs, fieldNumber: 6)
    }
    try { if let v = self._reply {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_SendMessageRequest, rhs: Client_SendMessageRequest) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs._messagePayload != rhs._messagePayload {return false}
    if lhs._simpayload != rhs._simpayload {return false}
    if lhs.tmpID != rhs.tmpID {return false}
    if lhs.forceRcs != rhs.forceRcs {return false}
    if lhs._reply != rhs._reply {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ReplyPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplyPayload"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}messageID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ReplyPayload, rhs: Client_ReplyPayload) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_MessagePayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessagePayload"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tmpID\0\u{2}\u{5}messagePayloadContent\0\u{1}conversationID\0\u{2}\u{2}participantID\0\u{1}messageInfo\0\u{2}\u{2}tmpID2\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.tmpID) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._messagePayloadContent) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.participantID) }()
      case 10: try { try decoder.decodeRepeatedMessageField(value: &self.messageInfo) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self.tmpID2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.tmpID.isEmpty {
      try visitor.visitSingularStringField(value: self.tmpID, fieldNumber: 1)
    }
    try { if let v = self._messagePayloadContent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 7)
    }
    if !self.participantID.isEmpty {
      try visitor.visitSingularStringField(value: self.participantID, fieldNumber: 9)
    }
    if !self.messageInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.messageInfo, fieldNumber: 10)
    }
    if !self.tmpID2.isEmpty {
      try visitor.visitSingularStringField(value: self.tmpID2, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_MessagePayload, rhs: Client_MessagePayload) -> Bool {
    if lhs.tmpID != rhs.tmpID {return false}
    if lhs._messagePayloadContent != rhs._messagePayloadContent {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.participantID != rhs.participantID {return false}
    if lhs.messageInfo != rhs.messageInfo {return false}
    if lhs.tmpID2 != rhs.tmpID2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_MessagePayloadContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessagePayloadContent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}messageContent\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._messageContent) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._messageContent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_MessagePayloadContent, rhs: Client_MessagePayloadContent) -> Bool {
    if lhs._messageContent != rhs._messageContent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_SendMessageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendMessageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}googleAccountSwitch\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._googleAccountSwitch) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._googleAccountSwitch {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_SendMessageResponse, rhs: Client_SendMessageResponse) -> Bool {
    if lhs._googleAccountSwitch != rhs._googleAccountSwitch {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_SendMessageResponse.Status: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN\0\u{1}SUCCESS\0\u{1}FAILURE_2\0\u{1}FAILURE_3\0\u{1}FAILURE_4\0")
}

extension Client_SendReactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendReactionRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}messageID\0\u{1}reactionData\0\u{1}action\0\u{1}SIMPayload\0")

  fileprivate class _StorageClass {
    var _messageID: String = String()
    var _reactionData: Conversations_ReactionData? = nil
    var _action: Client_SendReactionRequest.Action = .unspecified
    var _simpayload: Settings_SIMPayload? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _messageID = source._messageID
      _reactionData = source._reactionData
      _action = source._action
      _simpayload = source._simpayload
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._messageID) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._reactionData) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._action) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._simpayload) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._messageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._messageID, fieldNumber: 1)
      }
      try { if let v = _storage._reactionData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._action != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._action, fieldNumber: 3)
      }
      try { if let v = _storage._simpayload {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_SendReactionRequest, rhs: Client_SendReactionRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._messageID != rhs_storage._messageID {return false}
        if _storage._reactionData != rhs_storage._reactionData {return false}
        if _storage._action != rhs_storage._action {return false}
        if _storage._simpayload != rhs_storage._simpayload {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_SendReactionRequest.Action: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNSPECIFIED\0\u{1}ADD\0\u{1}REMOVE\0\u{1}SWITCH\0")
}

extension Client_SendReactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SendReactionResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_SendReactionResponse, rhs: Client_SendReactionResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_ResendMessageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResendMessageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}messageID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_ResendMessageRequest, rhs: Client_ResendMessageRequest) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_TypingUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TypingUpdateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}data\0\u{1}SIMPayload\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._simpayload) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._simpayload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_TypingUpdateRequest, rhs: Client_TypingUpdateRequest) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs._simpayload != rhs._simpayload {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_TypingUpdateRequest.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Client_TypingUpdateRequest.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conversationID\0\u{2}\u{2}typing\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.typing) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    if self.typing != false {
      try visitor.visitSingularBoolField(value: self.typing, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_TypingUpdateRequest.DataMessage, rhs: Client_TypingUpdateRequest.DataMessage) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.typing != rhs.typing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_SettingsUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SettingsUpdateRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{3}pushSettings\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularMessageField(value: &self._pushSettings) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._pushSettings {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_SettingsUpdateRequest, rhs: Client_SettingsUpdateRequest) -> Bool {
    if lhs._pushSettings != rhs._pushSettings {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_SettingsUpdateRequest.PushSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Client_SettingsUpdateRequest.protoMessageName + ".PushSettings"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{3}enabled\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_SettingsUpdateRequest.PushSettings, rhs: Client_SettingsUpdateRequest.PushSettings) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_GetFullSizeImageRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFullSizeImageRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}messageID\0\u{1}actionMessageID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.actionMessageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if !self.actionMessageID.isEmpty {
      try visitor.visitSingularStringField(value: self.actionMessageID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_GetFullSizeImageRequest, rhs: Client_GetFullSizeImageRequest) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.actionMessageID != rhs.actionMessageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Client_GetFullSizeImageResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GetFullSizeImageResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Client_GetFullSizeImageResponse, rhs: Client_GetFullSizeImageResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
