// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: events.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Events_AlertType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0

  /// Emitted whenever browser connection becomes inactive
  case browserInactive // = 1

  /// Emitted whenever a new browser session is created
  case browserActive // = 2

  /// Emitted when the paired device connects to data
  case mobileDataConnection // = 3

  /// Emitted when the paired device connects to wifi
  case mobileWifiConnection // = 4

  /// Emitted if the paired device reaches low battery
  case mobileBatteryLow // = 5

  /// Emitted if the paired device has restored battery enough to not be considered low
  case mobileBatteryRestored // = 6

  /// Emitted whenever browser connection becomes inactive due to timeout
  case browserInactiveFromTimeout // = 7

  /// Emitted whenever browser connection becomes inactive due to inactivity
  case browserInactiveFromInactivity // = 8

  /// Emitted whenever RCS connection has been established successfully
  case rcsConnection // = 9

  /// Unknown
  case observerRegistered // = 10

  /// Emitted whenever the paired device is attempting to sync db
  case mobileDatabaseSyncing // = 11

  /// Emitted whenever the paired device has completed the db sync
  case mobileDatabaseSyncComplete // = 12

  /// Emitted whenever the paired device has begun syncing the db
  case mobileDatabaseSyncStarted // = 13

  /// Emitted whenever the paired device has successfully synced a chunk of the db
  case mobileDatabasePartialSyncCompleted // = 14

  /// Emitted whenever the paired device has begun syncing a chunk of the db
  case mobileDatabasePartialSyncStarted // = 15

  /// Emitted whenever the paired device has begun refreshing contacts
  case contactsRefreshStarted // = 16

  /// Emitted whenever the paired device has successfully refreshed contacts
  case contactsRefreshCompleted // = 17
  case disconnectedFromSatellite // = 18
  case brMessageRestoring // = 19
  case brMessageRestoreCompleted // = 20
  case brMessageRestoreStarted // = 21
  case pushThrottling // = 22
  case pushThrottleStarted // = 23
  case pushThrottleEnded // = 24
  case pushThrottleStartedInDarkLaunch // = 25
  case pushThrottleEndedInDarkLaunch // = 26
  case pushThrottlingInDarkLaunch // = 27
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .browserInactive
    case 2: self = .browserActive
    case 3: self = .mobileDataConnection
    case 4: self = .mobileWifiConnection
    case 5: self = .mobileBatteryLow
    case 6: self = .mobileBatteryRestored
    case 7: self = .browserInactiveFromTimeout
    case 8: self = .browserInactiveFromInactivity
    case 9: self = .rcsConnection
    case 10: self = .observerRegistered
    case 11: self = .mobileDatabaseSyncing
    case 12: self = .mobileDatabaseSyncComplete
    case 13: self = .mobileDatabaseSyncStarted
    case 14: self = .mobileDatabasePartialSyncCompleted
    case 15: self = .mobileDatabasePartialSyncStarted
    case 16: self = .contactsRefreshStarted
    case 17: self = .contactsRefreshCompleted
    case 18: self = .disconnectedFromSatellite
    case 19: self = .brMessageRestoring
    case 20: self = .brMessageRestoreCompleted
    case 21: self = .brMessageRestoreStarted
    case 22: self = .pushThrottling
    case 23: self = .pushThrottleStarted
    case 24: self = .pushThrottleEnded
    case 25: self = .pushThrottleStartedInDarkLaunch
    case 26: self = .pushThrottleEndedInDarkLaunch
    case 27: self = .pushThrottlingInDarkLaunch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .browserInactive: return 1
    case .browserActive: return 2
    case .mobileDataConnection: return 3
    case .mobileWifiConnection: return 4
    case .mobileBatteryLow: return 5
    case .mobileBatteryRestored: return 6
    case .browserInactiveFromTimeout: return 7
    case .browserInactiveFromInactivity: return 8
    case .rcsConnection: return 9
    case .observerRegistered: return 10
    case .mobileDatabaseSyncing: return 11
    case .mobileDatabaseSyncComplete: return 12
    case .mobileDatabaseSyncStarted: return 13
    case .mobileDatabasePartialSyncCompleted: return 14
    case .mobileDatabasePartialSyncStarted: return 15
    case .contactsRefreshStarted: return 16
    case .contactsRefreshCompleted: return 17
    case .disconnectedFromSatellite: return 18
    case .brMessageRestoring: return 19
    case .brMessageRestoreCompleted: return 20
    case .brMessageRestoreStarted: return 21
    case .pushThrottling: return 22
    case .pushThrottleStarted: return 23
    case .pushThrottleEnded: return 24
    case .pushThrottleStartedInDarkLaunch: return 25
    case .pushThrottleEndedInDarkLaunch: return 26
    case .pushThrottlingInDarkLaunch: return 27
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Events_AlertType] = [
    .unknown,
    .browserInactive,
    .browserActive,
    .mobileDataConnection,
    .mobileWifiConnection,
    .mobileBatteryLow,
    .mobileBatteryRestored,
    .browserInactiveFromTimeout,
    .browserInactiveFromInactivity,
    .rcsConnection,
    .observerRegistered,
    .mobileDatabaseSyncing,
    .mobileDatabaseSyncComplete,
    .mobileDatabaseSyncStarted,
    .mobileDatabasePartialSyncCompleted,
    .mobileDatabasePartialSyncStarted,
    .contactsRefreshStarted,
    .contactsRefreshCompleted,
    .disconnectedFromSatellite,
    .brMessageRestoring,
    .brMessageRestoreCompleted,
    .brMessageRestoreStarted,
    .pushThrottling,
    .pushThrottleStarted,
    .pushThrottleEnded,
    .pushThrottleStartedInDarkLaunch,
    .pushThrottleEndedInDarkLaunch,
    .pushThrottlingInDarkLaunch,
  ]

}

public enum Events_TypingTypes: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case stoppedTyping // = 0
  case startedTyping // = 1
  case UNRECOGNIZED(Int)

  public init() {
    self = .stoppedTyping
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stoppedTyping
    case 1: self = .startedTyping
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .stoppedTyping: return 0
    case .startedTyping: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Events_TypingTypes] = [
    .stoppedTyping,
    .startedTyping,
  ]

}

public struct Events_UpdateEvents: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var event: Events_UpdateEvents.OneOf_Event? = nil

  public var conversationEvent: Events_ConversationEvent {
    get {
      if case .conversationEvent(let v)? = event {return v}
      return Events_ConversationEvent()
    }
    set {event = .conversationEvent(newValue)}
  }

  public var messageEvent: Events_MessageEvent {
    get {
      if case .messageEvent(let v)? = event {return v}
      return Events_MessageEvent()
    }
    set {event = .messageEvent(newValue)}
  }

  public var typingEvent: Events_TypingEvent {
    get {
      if case .typingEvent(let v)? = event {return v}
      return Events_TypingEvent()
    }
    set {event = .typingEvent(newValue)}
  }

  public var settingsEvent: Settings_Settings {
    get {
      if case .settingsEvent(let v)? = event {return v}
      return Settings_Settings()
    }
    set {event = .settingsEvent(newValue)}
  }

  public var userAlertEvent: Events_UserAlertEvent {
    get {
      if case .userAlertEvent(let v)? = event {return v}
      return Events_UserAlertEvent()
    }
    set {event = .userAlertEvent(newValue)}
  }

  public var browserPresenceCheckEvent: Events_BrowserPresenceCheckEvent {
    get {
      if case .browserPresenceCheckEvent(let v)? = event {return v}
      return Events_BrowserPresenceCheckEvent()
    }
    set {event = .browserPresenceCheckEvent(newValue)}
  }

  ///ParticipantsEvent participantsEvent = 8;
  ///ConversationTypeEvent conversationTypeEvent = 9;
  ///FavoriteStickersEvent favoriteStickersEvent = 10;
  ///RecentStickerEvent recentStickerEvent = 11;
  ///CloudStoreInfoEvent cloudStoreInfoEvent = 12;
  ///BlobForAttachmentProgressUpdate blobForAttachmentProgressUpdate = 13;
  public var accountChange: Events_AccountChangeOrSomethingEvent {
    get {
      if case .accountChange(let v)? = event {return v}
      return Events_AccountChangeOrSomethingEvent()
    }
    set {event = .accountChange(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Event: Equatable, Sendable {
    case conversationEvent(Events_ConversationEvent)
    case messageEvent(Events_MessageEvent)
    case typingEvent(Events_TypingEvent)
    case settingsEvent(Settings_Settings)
    case userAlertEvent(Events_UserAlertEvent)
    case browserPresenceCheckEvent(Events_BrowserPresenceCheckEvent)
    ///ParticipantsEvent participantsEvent = 8;
    ///ConversationTypeEvent conversationTypeEvent = 9;
    ///FavoriteStickersEvent favoriteStickersEvent = 10;
    ///RecentStickerEvent recentStickerEvent = 11;
    ///CloudStoreInfoEvent cloudStoreInfoEvent = 12;
    ///BlobForAttachmentProgressUpdate blobForAttachmentProgressUpdate = 13;
    case accountChange(Events_AccountChangeOrSomethingEvent)

  }

  public init() {}
}

public struct Events_EncryptedData2Container: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var accountChange: Events_AccountChangeOrSomethingEvent {
    get {return _accountChange ?? Events_AccountChangeOrSomethingEvent()}
    set {_accountChange = newValue}
  }
  /// Returns true if `accountChange` has been explicitly set.
  public var hasAccountChange: Bool {return self._accountChange != nil}
  /// Clears the value of `accountChange`. Subsequent reads from it will return its default value.
  public mutating func clearAccountChange() {self._accountChange = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _accountChange: Events_AccountChangeOrSomethingEvent? = nil
}

public struct Events_AccountChangeOrSomethingEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: String = String()

  public var enabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Events_ConversationEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Conversations_Conversation] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Events_TypingEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Events_TypingData {
    get {return _data ?? Events_TypingData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Events_TypingData? = nil
}

public struct Events_MessageEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: [Conversations_Message] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Events_UserAlertEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var alertType: Events_AlertType = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Events_BrowserPresenceCheckEvent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Events_TypingData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String = String()

  public var user: Events_User {
    get {return _user ?? Events_User()}
    set {_user = newValue}
  }
  /// Returns true if `user` has been explicitly set.
  public var hasUser: Bool {return self._user != nil}
  /// Clears the value of `user`. Subsequent reads from it will return its default value.
  public mutating func clearUser() {self._user = nil}

  public var type: Events_TypingTypes = .stoppedTyping

  public var someKindOfGroupID: Conversations_SomeKindOfGroupID {
    get {return _someKindOfGroupID ?? Conversations_SomeKindOfGroupID()}
    set {_someKindOfGroupID = newValue}
  }
  /// Returns true if `someKindOfGroupID` has been explicitly set.
  public var hasSomeKindOfGroupID: Bool {return self._someKindOfGroupID != nil}
  /// Clears the value of `someKindOfGroupID`. Subsequent reads from it will return its default value.
  public mutating func clearSomeKindOfGroupID() {self._someKindOfGroupID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _user: Events_User? = nil
  fileprivate var _someKindOfGroupID: Conversations_SomeKindOfGroupID? = nil
}

public struct Events_MoreTypingData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String = String()

  /// Field 2 has some weird hash or something in groups?
  public var number: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Events_User: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var field1: Int64 = 0

  public var number: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Events_RPCPairData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var event: Events_RPCPairData.OneOf_Event? = nil

  public var paired: Authentication_PairedData {
    get {
      if case .paired(let v)? = event {return v}
      return Authentication_PairedData()
    }
    set {event = .paired(newValue)}
  }

  public var revoked: Authentication_RevokePairData {
    get {
      if case .revoked(let v)? = event {return v}
      return Authentication_RevokePairData()
    }
    set {event = .revoked(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Event: Equatable, Sendable {
    case paired(Authentication_PairedData)
    case revoked(Authentication_RevokePairData)

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "events"

extension Events_AlertType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ALERT_TYPE_UNKNOWN\0\u{1}BROWSER_INACTIVE\0\u{1}BROWSER_ACTIVE\0\u{1}MOBILE_DATA_CONNECTION\0\u{1}MOBILE_WIFI_CONNECTION\0\u{1}MOBILE_BATTERY_LOW\0\u{1}MOBILE_BATTERY_RESTORED\0\u{1}BROWSER_INACTIVE_FROM_TIMEOUT\0\u{1}BROWSER_INACTIVE_FROM_INACTIVITY\0\u{1}RCS_CONNECTION\0\u{1}OBSERVER_REGISTERED\0\u{1}MOBILE_DATABASE_SYNCING\0\u{1}MOBILE_DATABASE_SYNC_COMPLETE\0\u{1}MOBILE_DATABASE_SYNC_STARTED\0\u{1}MOBILE_DATABASE_PARTIAL_SYNC_COMPLETED\0\u{1}MOBILE_DATABASE_PARTIAL_SYNC_STARTED\0\u{1}CONTACTS_REFRESH_STARTED\0\u{1}CONTACTS_REFRESH_COMPLETED\0\u{1}DISCONNECTED_FROM_SATELLITE\0\u{1}BR_MESSAGE_RESTORING\0\u{1}BR_MESSAGE_RESTORE_COMPLETED\0\u{1}BR_MESSAGE_RESTORE_STARTED\0\u{1}PUSH_THROTTLING\0\u{1}PUSH_THROTTLE_STARTED\0\u{1}PUSH_THROTTLE_ENDED\0\u{1}PUSH_THROTTLE_STARTED_IN_DARK_LAUNCH\0\u{1}PUSH_THROTTLE_ENDED_IN_DARK_LAUNCH\0\u{1}PUSH_THROTTLING_IN_DARK_LAUNCH\0")
}

extension Events_TypingTypes: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0STOPPED_TYPING\0\u{1}STARTED_TYPING\0")
}

extension Events_UpdateEvents: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UpdateEvents"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}conversationEvent\0\u{1}messageEvent\0\u{1}typingEvent\0\u{1}settingsEvent\0\u{1}userAlertEvent\0\u{1}browserPresenceCheckEvent\0\u{2}\u{8}accountChange\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try {
        var v: Events_ConversationEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .conversationEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .conversationEvent(v)
        }
      }()
      case 3: try {
        var v: Events_MessageEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .messageEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .messageEvent(v)
        }
      }()
      case 4: try {
        var v: Events_TypingEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .typingEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .typingEvent(v)
        }
      }()
      case 5: try {
        var v: Settings_Settings?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .settingsEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .settingsEvent(v)
        }
      }()
      case 6: try {
        var v: Events_UserAlertEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .userAlertEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .userAlertEvent(v)
        }
      }()
      case 7: try {
        var v: Events_BrowserPresenceCheckEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .browserPresenceCheckEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .browserPresenceCheckEvent(v)
        }
      }()
      case 15: try {
        var v: Events_AccountChangeOrSomethingEvent?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .accountChange(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .accountChange(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .conversationEvent?: try {
      guard case .conversationEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .messageEvent?: try {
      guard case .messageEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .typingEvent?: try {
      guard case .typingEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .settingsEvent?: try {
      guard case .settingsEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .userAlertEvent?: try {
      guard case .userAlertEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .browserPresenceCheckEvent?: try {
      guard case .browserPresenceCheckEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .accountChange?: try {
      guard case .accountChange(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_UpdateEvents, rhs: Events_UpdateEvents) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_EncryptedData2Container: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EncryptedData2Container"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}accountChange\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._accountChange) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountChange {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_EncryptedData2Container, rhs: Events_EncryptedData2Container) -> Bool {
    if lhs._accountChange != rhs._accountChange {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_AccountChangeOrSomethingEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountChangeOrSomethingEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}account\0\u{1}enabled\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.account) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularStringField(value: self.account, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_AccountChangeOrSomethingEvent, rhs: Events_AccountChangeOrSomethingEvent) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_ConversationEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConversationEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_ConversationEvent, rhs: Events_ConversationEvent) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_TypingEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TypingEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_TypingEvent, rhs: Events_TypingEvent) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MessageEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.data, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_MessageEvent, rhs: Events_MessageEvent) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_UserAlertEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".UserAlertEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}alertType\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.alertType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.alertType != .unknown {
      try visitor.visitSingularEnumField(value: self.alertType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_UserAlertEvent, rhs: Events_UserAlertEvent) -> Bool {
    if lhs.alertType != rhs.alertType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_BrowserPresenceCheckEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BrowserPresenceCheckEvent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_BrowserPresenceCheckEvent, rhs: Events_BrowserPresenceCheckEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_TypingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TypingData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conversationID\0\u{1}user\0\u{1}type\0\u{1}someKindOfGroupID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._user) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._someKindOfGroupID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    try { if let v = self._user {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.type != .stoppedTyping {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 3)
    }
    try { if let v = self._someKindOfGroupID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_TypingData, rhs: Events_TypingData) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs._user != rhs._user {return false}
    if lhs.type != rhs.type {return false}
    if lhs._someKindOfGroupID != rhs._someKindOfGroupID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_MoreTypingData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MoreTypingData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conversationID\0\u{2}\u{2}number\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.number) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    if !self.number.isEmpty {
      try visitor.visitRepeatedStringField(value: self.number, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_MoreTypingData, rhs: Events_MoreTypingData) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_User: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".User"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}field1\0\u{1}number\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.field1) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.number) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.field1 != 0 {
      try visitor.visitSingularInt64Field(value: self.field1, fieldNumber: 1)
    }
    if !self.number.isEmpty {
      try visitor.visitSingularStringField(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_User, rhs: Events_User) -> Bool {
    if lhs.field1 != rhs.field1 {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Events_RPCPairData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RPCPairData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{4}paired\0\u{1}revoked\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 4: try {
        var v: Authentication_PairedData?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .paired(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .paired(v)
        }
      }()
      case 5: try {
        var v: Authentication_RevokePairData?
        var hadOneofValue = false
        if let current = self.event {
          hadOneofValue = true
          if case .revoked(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.event = .revoked(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.event {
    case .paired?: try {
      guard case .paired(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .revoked?: try {
      guard case .revoked(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Events_RPCPairData, rhs: Events_RPCPairData) -> Bool {
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
