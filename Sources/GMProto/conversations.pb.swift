// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: conversations.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Conversations_EmojiType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case reactionTypeUnspecified // = 0
  case like // = 1
  case love // = 2
  case laugh // = 3
  case surprised // = 4
  case sad // = 5
  case angry // = 6
  case dislike // = 7
  case custom // = 8
  case questioning // = 9
  case cryingFace // = 10
  case poutingFace // = 11
  case redHeart // = 12
  case emotify // = 13
  case UNRECOGNIZED(Int)

  public init() {
    self = .reactionTypeUnspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .reactionTypeUnspecified
    case 1: self = .like
    case 2: self = .love
    case 3: self = .laugh
    case 4: self = .surprised
    case 5: self = .sad
    case 6: self = .angry
    case 7: self = .dislike
    case 8: self = .custom
    case 9: self = .questioning
    case 10: self = .cryingFace
    case 11: self = .poutingFace
    case 12: self = .redHeart
    case 13: self = .emotify
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .reactionTypeUnspecified: return 0
    case .like: return 1
    case .love: return 2
    case .laugh: return 3
    case .surprised: return 4
    case .sad: return 5
    case .angry: return 6
    case .dislike: return 7
    case .custom: return 8
    case .questioning: return 9
    case .cryingFace: return 10
    case .poutingFace: return 11
    case .redHeart: return 12
    case .emotify: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Conversations_EmojiType] = [
    .reactionTypeUnspecified,
    .like,
    .love,
    .laugh,
    .surprised,
    .sad,
    .angry,
    .dislike,
    .custom,
    .questioning,
    .cryingFace,
    .poutingFace,
    .redHeart,
    .emotify,
  ]

}

public enum Conversations_IdentifierType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case phone // = 1
  case email // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .phone
    case 2: self = .email
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .phone: return 1
    case .email: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Conversations_IdentifierType] = [
    .unknown,
    .phone,
    .email,
  ]

}

public enum Conversations_ConversationSendMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case sendModeAuto // = 0
  case sendModeXms // = 1
  case sendModeXmsLatch // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .sendModeAuto
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sendModeAuto
    case 1: self = .sendModeXms
    case 2: self = .sendModeXmsLatch
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .sendModeAuto: return 0
    case .sendModeXms: return 1
    case .sendModeXmsLatch: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Conversations_ConversationSendMode] = [
    .sendModeAuto,
    .sendModeXms,
    .sendModeXmsLatch,
  ]

}

public enum Conversations_ConversationType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknownConversationType // = 0
  case sms // = 1
  case rcs // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownConversationType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownConversationType
    case 1: self = .sms
    case 2: self = .rcs
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownConversationType: return 0
    case .sms: return 1
    case .rcs: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Conversations_ConversationType] = [
    .unknownConversationType,
    .sms,
    .rcs,
  ]

}

public enum Conversations_MessageStatusType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case statusUnknown // = 0
  case outgoingComplete // = 1
  case outgoingDelivered // = 2
  case outgoingDisplayed // = 11
  case outgoingDraft // = 3
  case outgoingSendAfterProcessing // = 10
  case outgoingYetToSend // = 4
  case outgoingSending // = 5
  case outgoingResending // = 6
  case outgoingAwaitingRetry // = 7
  case outgoingFailedGeneric // = 8
  case outgoingFailedEmergencyNumber // = 9
  case outgoingCanceled // = 12
  case outgoingFailedTooLarge // = 13
  case outgoingNotDeliveredYet // = 14
  case outgoingRevocationPending // = 15
  case outgoingScheduled // = 16
  case outgoingFailedRecipientLostRcs // = 17
  case outgoingFailedNoRetryNoFallback // = 18
  case outgoingFailedRecipientDidNotDecrypt // = 19
  case outgoingValidating // = 20
  case outgoingFailedRecipientLostEncryption // = 21
  case outgoingFailedRecipientDidNotDecryptNoMoreRetry // = 22
  case incomingComplete // = 100
  case incomingYetToManualDownload // = 101
  case incomingRetryingManualDownload // = 102
  case incomingManualDownloading // = 103
  case incomingRetryingAutoDownload // = 104
  case incomingAutoDownloading // = 105
  case incomingDownloadFailed // = 106
  case incomingExpiredOrNotAvailable // = 107
  case incomingDelivered // = 108
  case incomingDisplayed // = 109
  case incomingDownloadCanceled // = 110
  case incomingDownloadFailedTooLarge // = 111
  case incomingDownloadFailedSimHasNoData // = 112
  case incomingFailedToDecrypt // = 113
  case incomingDecryptionAborted // = 114
  case tombstoneParticipantJoined // = 200
  case tombstoneParticipantLeft // = 201
  case tombstoneSelfLeft // = 202
  case tombstoneRcsGroupCreated // = 203
  case tombstoneMmsGroupCreated // = 204
  case tombstoneSmsBroadcastCreated // = 205
  case tombstoneOneOnOneSmsCreated // = 206
  case tombstoneOneOnOneRcsCreated // = 207
  case tombstoneSwitchToGroupMms // = 208
  case tombstoneSwitchToBroadcastSms // = 209
  case tombstoneShowLinkPreviews // = 210
  case tombstoneGroupRenamedLocal // = 211
  case tombstoneVerifiedSmsApplicable // = 212
  case tombstoneEncryptedOneOnOneRcsCreated // = 213
  case tombstoneProtocolSwitchToText // = 214
  case tombstoneProtocolSwitchToRcs // = 215
  case tombstoneProtocolSwitchToEncryptedRcs // = 216
  case tombstoneGroupRenamedGlobal // = 217
  case tombstoneGroupNameClearedGlobal // = 218
  case tombstoneProtocolSwitchToEncryptedRcsInfo // = 219
  case tombstoneSelfRemovedFromGroup // = 220
  case messageStatusTombstoneParticipantRemovedFromGroup // = 221
  case messageStatusTombstoneSmsNormParticipantUpgraded // = 222
  case messageStatusTombstoneRcsNormParticipantUpgraded // = 223
  case messageStatusTombstoneEncryptedRcsNormParticipantUpgraded // = 224
  case messageStatusTombstoneEncryptedGroupParticipantJoined // = 225
  case messageStatusTombstoneEncryptedGroupParticipantJoinedInfo // = 226
  case messageStatusTombstoneEncryptedGroupParticipantLeft // = 227
  case messageStatusTombstoneEncryptedGroupSelfLeft // = 228
  case messageStatusTombstoneEncryptedGroupCreated // = 229
  case messageStatusTombstoneSelfRemovedFromEncryptedGroup // = 230
  case messageStatusTombstoneParticipantRemovedFromEncryptedGroup // = 231
  case messageStatusTombstoneSuggestionShortcutStarToolstone // = 232
  case messageStatusTombstoneGroupProtocolSwitchRcsToE2Ee // = 233
  case messageStatusTombstoneGroupProtocolSwitchE2EeToRcs // = 234
  case messageStatusTombstoneProtocolSwitchTextToE2Ee // = 235
  case messageStatusTombstoneProtocolSwitchE2EeToText // = 236
  case messageStatusTombstoneProtocolSwitchRcsToE2Ee // = 237
  case messageStatusTombstoneProtocolSwitchE2EeToRcs // = 238
  case messageStatusTombstoneSatelliteEducation // = 239
  case messageStatusTombstoneRbmSimSwitch // = 240
  case messageStatusTombstoneRbmPrivacyNotice // = 241
  case messageStatusTombstonePenpalConversationNotice // = 242
  case messageStatusTombstoneMeetOtherParticipantReachable // = 243
  case messageStatusTombstoneMissedVideoCall // = 244
  case messageStatusTombstoneParticipantThemeChange // = 245
  case messageStatusTombstoneSatelliteEndOfEmergencySuccessHelpStillNeeded // = 246
  case messageStatusTombstoneSatelliteEndOfEmergencySuccessHelpNoLongerNeeded // = 247
  case messageStatusTombstoneSatelliteEndOfEmergencyFailureHelpStillNeeded // = 248
  case messageStatusTombstoneSatelliteEndOfEmergencyFailureHelpNoLongerNeeded // = 249
  case messageStatusTombstoneSatelliteEndOfEmergencyUnexpectedEnd // = 250
  case messageStatusTombstoneSatelliteMessagingToolstone // = 251
  case messageStatusTombstoneGroupProtocolSwitchE2EeToMms // = 252
  case messageStatusTombstonePenpalProactiveMessageNotice // = 253
  case messageStatusTombstoneSuggestionPossibleScamToolstone // = 254
  case messageStatusTombstoneChatbotUnsubscribeSent // = 255
  case messageStatusTombstoneChatbotSubscribeSent // = 256
  case messageStatusTombstoneChatbotUnsubscribeConfirmed // = 257
  case messageStatusTombstoneChatbotSubscribeConfirmed // = 258
  case messageStatusTombstoneActiveSelfIdentityChanged // = 259
  case messageStatusTombstoneGroupIconChangedGlobal // = 260
  case messageStatusTombstoneGroupIconClearedGlobal // = 261
  case messageStatusTombstoneChatbotUnsubscribeError // = 262
  case messageStatusTombstoneChatbotSubscribeError // = 263
  case messageStatusTombstoneEmergencyConversationCreated // = 264
  case messageStatusTombstoneSensitiveContentWarningToolstone // = 265
  case messageStatusTombstoneChatbotUnsubscribeConfirmedNoLink // = 266
  case messageStatusTombstoneChatbotSubscribeConfirmedNoLink // = 267
  case messageStatusTombstoneEmergencyQuestionnaire // = 268
  case messageStatusTombstoneChatbotUnsubscribeSentNoLink // = 269
  case messageStatusTombstoneChatbotSubscribeSentNoLink // = 270
  case messageStatusTombstoneRcsGroupJoinedByLink // = 271
  case messageStatusTombstoneInviteLinkEnabled // = 272
  case messageStatusTombstoneInviteLinkDisabled // = 273
  case messageStatusTombstoneInviteLinkResetManually // = 274
  case messageStatusTombstoneInviteLinkResetAutomatically // = 275
  case messageDeleted // = 300
  case UNRECOGNIZED(Int)

  public init() {
    self = .statusUnknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .statusUnknown
    case 1: self = .outgoingComplete
    case 2: self = .outgoingDelivered
    case 3: self = .outgoingDraft
    case 4: self = .outgoingYetToSend
    case 5: self = .outgoingSending
    case 6: self = .outgoingResending
    case 7: self = .outgoingAwaitingRetry
    case 8: self = .outgoingFailedGeneric
    case 9: self = .outgoingFailedEmergencyNumber
    case 10: self = .outgoingSendAfterProcessing
    case 11: self = .outgoingDisplayed
    case 12: self = .outgoingCanceled
    case 13: self = .outgoingFailedTooLarge
    case 14: self = .outgoingNotDeliveredYet
    case 15: self = .outgoingRevocationPending
    case 16: self = .outgoingScheduled
    case 17: self = .outgoingFailedRecipientLostRcs
    case 18: self = .outgoingFailedNoRetryNoFallback
    case 19: self = .outgoingFailedRecipientDidNotDecrypt
    case 20: self = .outgoingValidating
    case 21: self = .outgoingFailedRecipientLostEncryption
    case 22: self = .outgoingFailedRecipientDidNotDecryptNoMoreRetry
    case 100: self = .incomingComplete
    case 101: self = .incomingYetToManualDownload
    case 102: self = .incomingRetryingManualDownload
    case 103: self = .incomingManualDownloading
    case 104: self = .incomingRetryingAutoDownload
    case 105: self = .incomingAutoDownloading
    case 106: self = .incomingDownloadFailed
    case 107: self = .incomingExpiredOrNotAvailable
    case 108: self = .incomingDelivered
    case 109: self = .incomingDisplayed
    case 110: self = .incomingDownloadCanceled
    case 111: self = .incomingDownloadFailedTooLarge
    case 112: self = .incomingDownloadFailedSimHasNoData
    case 113: self = .incomingFailedToDecrypt
    case 114: self = .incomingDecryptionAborted
    case 200: self = .tombstoneParticipantJoined
    case 201: self = .tombstoneParticipantLeft
    case 202: self = .tombstoneSelfLeft
    case 203: self = .tombstoneRcsGroupCreated
    case 204: self = .tombstoneMmsGroupCreated
    case 205: self = .tombstoneSmsBroadcastCreated
    case 206: self = .tombstoneOneOnOneSmsCreated
    case 207: self = .tombstoneOneOnOneRcsCreated
    case 208: self = .tombstoneSwitchToGroupMms
    case 209: self = .tombstoneSwitchToBroadcastSms
    case 210: self = .tombstoneShowLinkPreviews
    case 211: self = .tombstoneGroupRenamedLocal
    case 212: self = .tombstoneVerifiedSmsApplicable
    case 213: self = .tombstoneEncryptedOneOnOneRcsCreated
    case 214: self = .tombstoneProtocolSwitchToText
    case 215: self = .tombstoneProtocolSwitchToRcs
    case 216: self = .tombstoneProtocolSwitchToEncryptedRcs
    case 217: self = .tombstoneGroupRenamedGlobal
    case 218: self = .tombstoneGroupNameClearedGlobal
    case 219: self = .tombstoneProtocolSwitchToEncryptedRcsInfo
    case 220: self = .tombstoneSelfRemovedFromGroup
    case 221: self = .messageStatusTombstoneParticipantRemovedFromGroup
    case 222: self = .messageStatusTombstoneSmsNormParticipantUpgraded
    case 223: self = .messageStatusTombstoneRcsNormParticipantUpgraded
    case 224: self = .messageStatusTombstoneEncryptedRcsNormParticipantUpgraded
    case 225: self = .messageStatusTombstoneEncryptedGroupParticipantJoined
    case 226: self = .messageStatusTombstoneEncryptedGroupParticipantJoinedInfo
    case 227: self = .messageStatusTombstoneEncryptedGroupParticipantLeft
    case 228: self = .messageStatusTombstoneEncryptedGroupSelfLeft
    case 229: self = .messageStatusTombstoneEncryptedGroupCreated
    case 230: self = .messageStatusTombstoneSelfRemovedFromEncryptedGroup
    case 231: self = .messageStatusTombstoneParticipantRemovedFromEncryptedGroup
    case 232: self = .messageStatusTombstoneSuggestionShortcutStarToolstone
    case 233: self = .messageStatusTombstoneGroupProtocolSwitchRcsToE2Ee
    case 234: self = .messageStatusTombstoneGroupProtocolSwitchE2EeToRcs
    case 235: self = .messageStatusTombstoneProtocolSwitchTextToE2Ee
    case 236: self = .messageStatusTombstoneProtocolSwitchE2EeToText
    case 237: self = .messageStatusTombstoneProtocolSwitchRcsToE2Ee
    case 238: self = .messageStatusTombstoneProtocolSwitchE2EeToRcs
    case 239: self = .messageStatusTombstoneSatelliteEducation
    case 240: self = .messageStatusTombstoneRbmSimSwitch
    case 241: self = .messageStatusTombstoneRbmPrivacyNotice
    case 242: self = .messageStatusTombstonePenpalConversationNotice
    case 243: self = .messageStatusTombstoneMeetOtherParticipantReachable
    case 244: self = .messageStatusTombstoneMissedVideoCall
    case 245: self = .messageStatusTombstoneParticipantThemeChange
    case 246: self = .messageStatusTombstoneSatelliteEndOfEmergencySuccessHelpStillNeeded
    case 247: self = .messageStatusTombstoneSatelliteEndOfEmergencySuccessHelpNoLongerNeeded
    case 248: self = .messageStatusTombstoneSatelliteEndOfEmergencyFailureHelpStillNeeded
    case 249: self = .messageStatusTombstoneSatelliteEndOfEmergencyFailureHelpNoLongerNeeded
    case 250: self = .messageStatusTombstoneSatelliteEndOfEmergencyUnexpectedEnd
    case 251: self = .messageStatusTombstoneSatelliteMessagingToolstone
    case 252: self = .messageStatusTombstoneGroupProtocolSwitchE2EeToMms
    case 253: self = .messageStatusTombstonePenpalProactiveMessageNotice
    case 254: self = .messageStatusTombstoneSuggestionPossibleScamToolstone
    case 255: self = .messageStatusTombstoneChatbotUnsubscribeSent
    case 256: self = .messageStatusTombstoneChatbotSubscribeSent
    case 257: self = .messageStatusTombstoneChatbotUnsubscribeConfirmed
    case 258: self = .messageStatusTombstoneChatbotSubscribeConfirmed
    case 259: self = .messageStatusTombstoneActiveSelfIdentityChanged
    case 260: self = .messageStatusTombstoneGroupIconChangedGlobal
    case 261: self = .messageStatusTombstoneGroupIconClearedGlobal
    case 262: self = .messageStatusTombstoneChatbotUnsubscribeError
    case 263: self = .messageStatusTombstoneChatbotSubscribeError
    case 264: self = .messageStatusTombstoneEmergencyConversationCreated
    case 265: self = .messageStatusTombstoneSensitiveContentWarningToolstone
    case 266: self = .messageStatusTombstoneChatbotUnsubscribeConfirmedNoLink
    case 267: self = .messageStatusTombstoneChatbotSubscribeConfirmedNoLink
    case 268: self = .messageStatusTombstoneEmergencyQuestionnaire
    case 269: self = .messageStatusTombstoneChatbotUnsubscribeSentNoLink
    case 270: self = .messageStatusTombstoneChatbotSubscribeSentNoLink
    case 271: self = .messageStatusTombstoneRcsGroupJoinedByLink
    case 272: self = .messageStatusTombstoneInviteLinkEnabled
    case 273: self = .messageStatusTombstoneInviteLinkDisabled
    case 274: self = .messageStatusTombstoneInviteLinkResetManually
    case 275: self = .messageStatusTombstoneInviteLinkResetAutomatically
    case 300: self = .messageDeleted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .statusUnknown: return 0
    case .outgoingComplete: return 1
    case .outgoingDelivered: return 2
    case .outgoingDraft: return 3
    case .outgoingYetToSend: return 4
    case .outgoingSending: return 5
    case .outgoingResending: return 6
    case .outgoingAwaitingRetry: return 7
    case .outgoingFailedGeneric: return 8
    case .outgoingFailedEmergencyNumber: return 9
    case .outgoingSendAfterProcessing: return 10
    case .outgoingDisplayed: return 11
    case .outgoingCanceled: return 12
    case .outgoingFailedTooLarge: return 13
    case .outgoingNotDeliveredYet: return 14
    case .outgoingRevocationPending: return 15
    case .outgoingScheduled: return 16
    case .outgoingFailedRecipientLostRcs: return 17
    case .outgoingFailedNoRetryNoFallback: return 18
    case .outgoingFailedRecipientDidNotDecrypt: return 19
    case .outgoingValidating: return 20
    case .outgoingFailedRecipientLostEncryption: return 21
    case .outgoingFailedRecipientDidNotDecryptNoMoreRetry: return 22
    case .incomingComplete: return 100
    case .incomingYetToManualDownload: return 101
    case .incomingRetryingManualDownload: return 102
    case .incomingManualDownloading: return 103
    case .incomingRetryingAutoDownload: return 104
    case .incomingAutoDownloading: return 105
    case .incomingDownloadFailed: return 106
    case .incomingExpiredOrNotAvailable: return 107
    case .incomingDelivered: return 108
    case .incomingDisplayed: return 109
    case .incomingDownloadCanceled: return 110
    case .incomingDownloadFailedTooLarge: return 111
    case .incomingDownloadFailedSimHasNoData: return 112
    case .incomingFailedToDecrypt: return 113
    case .incomingDecryptionAborted: return 114
    case .tombstoneParticipantJoined: return 200
    case .tombstoneParticipantLeft: return 201
    case .tombstoneSelfLeft: return 202
    case .tombstoneRcsGroupCreated: return 203
    case .tombstoneMmsGroupCreated: return 204
    case .tombstoneSmsBroadcastCreated: return 205
    case .tombstoneOneOnOneSmsCreated: return 206
    case .tombstoneOneOnOneRcsCreated: return 207
    case .tombstoneSwitchToGroupMms: return 208
    case .tombstoneSwitchToBroadcastSms: return 209
    case .tombstoneShowLinkPreviews: return 210
    case .tombstoneGroupRenamedLocal: return 211
    case .tombstoneVerifiedSmsApplicable: return 212
    case .tombstoneEncryptedOneOnOneRcsCreated: return 213
    case .tombstoneProtocolSwitchToText: return 214
    case .tombstoneProtocolSwitchToRcs: return 215
    case .tombstoneProtocolSwitchToEncryptedRcs: return 216
    case .tombstoneGroupRenamedGlobal: return 217
    case .tombstoneGroupNameClearedGlobal: return 218
    case .tombstoneProtocolSwitchToEncryptedRcsInfo: return 219
    case .tombstoneSelfRemovedFromGroup: return 220
    case .messageStatusTombstoneParticipantRemovedFromGroup: return 221
    case .messageStatusTombstoneSmsNormParticipantUpgraded: return 222
    case .messageStatusTombstoneRcsNormParticipantUpgraded: return 223
    case .messageStatusTombstoneEncryptedRcsNormParticipantUpgraded: return 224
    case .messageStatusTombstoneEncryptedGroupParticipantJoined: return 225
    case .messageStatusTombstoneEncryptedGroupParticipantJoinedInfo: return 226
    case .messageStatusTombstoneEncryptedGroupParticipantLeft: return 227
    case .messageStatusTombstoneEncryptedGroupSelfLeft: return 228
    case .messageStatusTombstoneEncryptedGroupCreated: return 229
    case .messageStatusTombstoneSelfRemovedFromEncryptedGroup: return 230
    case .messageStatusTombstoneParticipantRemovedFromEncryptedGroup: return 231
    case .messageStatusTombstoneSuggestionShortcutStarToolstone: return 232
    case .messageStatusTombstoneGroupProtocolSwitchRcsToE2Ee: return 233
    case .messageStatusTombstoneGroupProtocolSwitchE2EeToRcs: return 234
    case .messageStatusTombstoneProtocolSwitchTextToE2Ee: return 235
    case .messageStatusTombstoneProtocolSwitchE2EeToText: return 236
    case .messageStatusTombstoneProtocolSwitchRcsToE2Ee: return 237
    case .messageStatusTombstoneProtocolSwitchE2EeToRcs: return 238
    case .messageStatusTombstoneSatelliteEducation: return 239
    case .messageStatusTombstoneRbmSimSwitch: return 240
    case .messageStatusTombstoneRbmPrivacyNotice: return 241
    case .messageStatusTombstonePenpalConversationNotice: return 242
    case .messageStatusTombstoneMeetOtherParticipantReachable: return 243
    case .messageStatusTombstoneMissedVideoCall: return 244
    case .messageStatusTombstoneParticipantThemeChange: return 245
    case .messageStatusTombstoneSatelliteEndOfEmergencySuccessHelpStillNeeded: return 246
    case .messageStatusTombstoneSatelliteEndOfEmergencySuccessHelpNoLongerNeeded: return 247
    case .messageStatusTombstoneSatelliteEndOfEmergencyFailureHelpStillNeeded: return 248
    case .messageStatusTombstoneSatelliteEndOfEmergencyFailureHelpNoLongerNeeded: return 249
    case .messageStatusTombstoneSatelliteEndOfEmergencyUnexpectedEnd: return 250
    case .messageStatusTombstoneSatelliteMessagingToolstone: return 251
    case .messageStatusTombstoneGroupProtocolSwitchE2EeToMms: return 252
    case .messageStatusTombstonePenpalProactiveMessageNotice: return 253
    case .messageStatusTombstoneSuggestionPossibleScamToolstone: return 254
    case .messageStatusTombstoneChatbotUnsubscribeSent: return 255
    case .messageStatusTombstoneChatbotSubscribeSent: return 256
    case .messageStatusTombstoneChatbotUnsubscribeConfirmed: return 257
    case .messageStatusTombstoneChatbotSubscribeConfirmed: return 258
    case .messageStatusTombstoneActiveSelfIdentityChanged: return 259
    case .messageStatusTombstoneGroupIconChangedGlobal: return 260
    case .messageStatusTombstoneGroupIconClearedGlobal: return 261
    case .messageStatusTombstoneChatbotUnsubscribeError: return 262
    case .messageStatusTombstoneChatbotSubscribeError: return 263
    case .messageStatusTombstoneEmergencyConversationCreated: return 264
    case .messageStatusTombstoneSensitiveContentWarningToolstone: return 265
    case .messageStatusTombstoneChatbotUnsubscribeConfirmedNoLink: return 266
    case .messageStatusTombstoneChatbotSubscribeConfirmedNoLink: return 267
    case .messageStatusTombstoneEmergencyQuestionnaire: return 268
    case .messageStatusTombstoneChatbotUnsubscribeSentNoLink: return 269
    case .messageStatusTombstoneChatbotSubscribeSentNoLink: return 270
    case .messageStatusTombstoneRcsGroupJoinedByLink: return 271
    case .messageStatusTombstoneInviteLinkEnabled: return 272
    case .messageStatusTombstoneInviteLinkDisabled: return 273
    case .messageStatusTombstoneInviteLinkResetManually: return 274
    case .messageStatusTombstoneInviteLinkResetAutomatically: return 275
    case .messageDeleted: return 300
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Conversations_MessageStatusType] = [
    .statusUnknown,
    .outgoingComplete,
    .outgoingDelivered,
    .outgoingDisplayed,
    .outgoingDraft,
    .outgoingSendAfterProcessing,
    .outgoingYetToSend,
    .outgoingSending,
    .outgoingResending,
    .outgoingAwaitingRetry,
    .outgoingFailedGeneric,
    .outgoingFailedEmergencyNumber,
    .outgoingCanceled,
    .outgoingFailedTooLarge,
    .outgoingNotDeliveredYet,
    .outgoingRevocationPending,
    .outgoingScheduled,
    .outgoingFailedRecipientLostRcs,
    .outgoingFailedNoRetryNoFallback,
    .outgoingFailedRecipientDidNotDecrypt,
    .outgoingValidating,
    .outgoingFailedRecipientLostEncryption,
    .outgoingFailedRecipientDidNotDecryptNoMoreRetry,
    .incomingComplete,
    .incomingYetToManualDownload,
    .incomingRetryingManualDownload,
    .incomingManualDownloading,
    .incomingRetryingAutoDownload,
    .incomingAutoDownloading,
    .incomingDownloadFailed,
    .incomingExpiredOrNotAvailable,
    .incomingDelivered,
    .incomingDisplayed,
    .incomingDownloadCanceled,
    .incomingDownloadFailedTooLarge,
    .incomingDownloadFailedSimHasNoData,
    .incomingFailedToDecrypt,
    .incomingDecryptionAborted,
    .tombstoneParticipantJoined,
    .tombstoneParticipantLeft,
    .tombstoneSelfLeft,
    .tombstoneRcsGroupCreated,
    .tombstoneMmsGroupCreated,
    .tombstoneSmsBroadcastCreated,
    .tombstoneOneOnOneSmsCreated,
    .tombstoneOneOnOneRcsCreated,
    .tombstoneSwitchToGroupMms,
    .tombstoneSwitchToBroadcastSms,
    .tombstoneShowLinkPreviews,
    .tombstoneGroupRenamedLocal,
    .tombstoneVerifiedSmsApplicable,
    .tombstoneEncryptedOneOnOneRcsCreated,
    .tombstoneProtocolSwitchToText,
    .tombstoneProtocolSwitchToRcs,
    .tombstoneProtocolSwitchToEncryptedRcs,
    .tombstoneGroupRenamedGlobal,
    .tombstoneGroupNameClearedGlobal,
    .tombstoneProtocolSwitchToEncryptedRcsInfo,
    .tombstoneSelfRemovedFromGroup,
    .messageStatusTombstoneParticipantRemovedFromGroup,
    .messageStatusTombstoneSmsNormParticipantUpgraded,
    .messageStatusTombstoneRcsNormParticipantUpgraded,
    .messageStatusTombstoneEncryptedRcsNormParticipantUpgraded,
    .messageStatusTombstoneEncryptedGroupParticipantJoined,
    .messageStatusTombstoneEncryptedGroupParticipantJoinedInfo,
    .messageStatusTombstoneEncryptedGroupParticipantLeft,
    .messageStatusTombstoneEncryptedGroupSelfLeft,
    .messageStatusTombstoneEncryptedGroupCreated,
    .messageStatusTombstoneSelfRemovedFromEncryptedGroup,
    .messageStatusTombstoneParticipantRemovedFromEncryptedGroup,
    .messageStatusTombstoneSuggestionShortcutStarToolstone,
    .messageStatusTombstoneGroupProtocolSwitchRcsToE2Ee,
    .messageStatusTombstoneGroupProtocolSwitchE2EeToRcs,
    .messageStatusTombstoneProtocolSwitchTextToE2Ee,
    .messageStatusTombstoneProtocolSwitchE2EeToText,
    .messageStatusTombstoneProtocolSwitchRcsToE2Ee,
    .messageStatusTombstoneProtocolSwitchE2EeToRcs,
    .messageStatusTombstoneSatelliteEducation,
    .messageStatusTombstoneRbmSimSwitch,
    .messageStatusTombstoneRbmPrivacyNotice,
    .messageStatusTombstonePenpalConversationNotice,
    .messageStatusTombstoneMeetOtherParticipantReachable,
    .messageStatusTombstoneMissedVideoCall,
    .messageStatusTombstoneParticipantThemeChange,
    .messageStatusTombstoneSatelliteEndOfEmergencySuccessHelpStillNeeded,
    .messageStatusTombstoneSatelliteEndOfEmergencySuccessHelpNoLongerNeeded,
    .messageStatusTombstoneSatelliteEndOfEmergencyFailureHelpStillNeeded,
    .messageStatusTombstoneSatelliteEndOfEmergencyFailureHelpNoLongerNeeded,
    .messageStatusTombstoneSatelliteEndOfEmergencyUnexpectedEnd,
    .messageStatusTombstoneSatelliteMessagingToolstone,
    .messageStatusTombstoneGroupProtocolSwitchE2EeToMms,
    .messageStatusTombstonePenpalProactiveMessageNotice,
    .messageStatusTombstoneSuggestionPossibleScamToolstone,
    .messageStatusTombstoneChatbotUnsubscribeSent,
    .messageStatusTombstoneChatbotSubscribeSent,
    .messageStatusTombstoneChatbotUnsubscribeConfirmed,
    .messageStatusTombstoneChatbotSubscribeConfirmed,
    .messageStatusTombstoneActiveSelfIdentityChanged,
    .messageStatusTombstoneGroupIconChangedGlobal,
    .messageStatusTombstoneGroupIconClearedGlobal,
    .messageStatusTombstoneChatbotUnsubscribeError,
    .messageStatusTombstoneChatbotSubscribeError,
    .messageStatusTombstoneEmergencyConversationCreated,
    .messageStatusTombstoneSensitiveContentWarningToolstone,
    .messageStatusTombstoneChatbotUnsubscribeConfirmedNoLink,
    .messageStatusTombstoneChatbotSubscribeConfirmedNoLink,
    .messageStatusTombstoneEmergencyQuestionnaire,
    .messageStatusTombstoneChatbotUnsubscribeSentNoLink,
    .messageStatusTombstoneChatbotSubscribeSentNoLink,
    .messageStatusTombstoneRcsGroupJoinedByLink,
    .messageStatusTombstoneInviteLinkEnabled,
    .messageStatusTombstoneInviteLinkDisabled,
    .messageStatusTombstoneInviteLinkResetManually,
    .messageStatusTombstoneInviteLinkResetAutomatically,
    .messageDeleted,
  ]

}

public enum Conversations_ConversationStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknownConversationStatus // = 0
  case active // = 1
  case archived // = 2
  case deleted // = 3
  case keepArchived // = 4
  case spamFolder // = 5
  case blockedFolder // = 6
  case crossCountryFolder // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownConversationStatus
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownConversationStatus
    case 1: self = .active
    case 2: self = .archived
    case 3: self = .deleted
    case 4: self = .keepArchived
    case 5: self = .spamFolder
    case 6: self = .blockedFolder
    case 7: self = .crossCountryFolder
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownConversationStatus: return 0
    case .active: return 1
    case .archived: return 2
    case .deleted: return 3
    case .keepArchived: return 4
    case .spamFolder: return 5
    case .blockedFolder: return 6
    case .crossCountryFolder: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Conversations_ConversationStatus] = [
    .unknownConversationStatus,
    .active,
    .archived,
    .deleted,
    .keepArchived,
    .spamFolder,
    .blockedFolder,
    .crossCountryFolder,
  ]

}

public enum Conversations_MediaFormats: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecifiedType // = 0
  case imageJpeg // = 1
  case imageJpg // = 2
  case imagePng // = 3
  case imageGif // = 4
  case imageWbmp // = 5
  case imageXMsBmp // = 6
  case imageUnspecified // = 7
  case videoMp4 // = 8
  case video3G2 // = 9
  case video3Gpp // = 10
  case videoWebm // = 11
  case videoMkv // = 12
  case videoUnspecified // = 13
  case audioAac // = 14
  case audioAmr // = 15
  case audioMp3 // = 16
  case audioMpeg // = 17
  case audioMpg // = 18
  case audioMp4 // = 19
  case audioMp4Latm // = 20
  case audio3Gpp // = 21
  case audioOgg // = 22
  case audioUnspecified // = 23
  case textVcard // = 24
  case appPdf // = 25
  case appTxt // = 26
  case appHtml // = 27
  case appDoc // = 28
  case appDocx // = 29
  case appPptx // = 30
  case appPpt // = 31
  case appXlsx // = 32
  case appXls // = 33
  case appApk // = 34
  case appZip // = 35
  case appJar // = 36
  case appUnspecified // = 37
  case calTextVcalendar // = 38
  case calTextXvcalendar // = 39
  case calTextCalendar // = 40
  case calApplicationVcs // = 41
  case calApplicationIcs // = 42
  case calApplicationHbsvcs // = 43
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecifiedType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecifiedType
    case 1: self = .imageJpeg
    case 2: self = .imageJpg
    case 3: self = .imagePng
    case 4: self = .imageGif
    case 5: self = .imageWbmp
    case 6: self = .imageXMsBmp
    case 7: self = .imageUnspecified
    case 8: self = .videoMp4
    case 9: self = .video3G2
    case 10: self = .video3Gpp
    case 11: self = .videoWebm
    case 12: self = .videoMkv
    case 13: self = .videoUnspecified
    case 14: self = .audioAac
    case 15: self = .audioAmr
    case 16: self = .audioMp3
    case 17: self = .audioMpeg
    case 18: self = .audioMpg
    case 19: self = .audioMp4
    case 20: self = .audioMp4Latm
    case 21: self = .audio3Gpp
    case 22: self = .audioOgg
    case 23: self = .audioUnspecified
    case 24: self = .textVcard
    case 25: self = .appPdf
    case 26: self = .appTxt
    case 27: self = .appHtml
    case 28: self = .appDoc
    case 29: self = .appDocx
    case 30: self = .appPptx
    case 31: self = .appPpt
    case 32: self = .appXlsx
    case 33: self = .appXls
    case 34: self = .appApk
    case 35: self = .appZip
    case 36: self = .appJar
    case 37: self = .appUnspecified
    case 38: self = .calTextVcalendar
    case 39: self = .calTextXvcalendar
    case 40: self = .calTextCalendar
    case 41: self = .calApplicationVcs
    case 42: self = .calApplicationIcs
    case 43: self = .calApplicationHbsvcs
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecifiedType: return 0
    case .imageJpeg: return 1
    case .imageJpg: return 2
    case .imagePng: return 3
    case .imageGif: return 4
    case .imageWbmp: return 5
    case .imageXMsBmp: return 6
    case .imageUnspecified: return 7
    case .videoMp4: return 8
    case .video3G2: return 9
    case .video3Gpp: return 10
    case .videoWebm: return 11
    case .videoMkv: return 12
    case .videoUnspecified: return 13
    case .audioAac: return 14
    case .audioAmr: return 15
    case .audioMp3: return 16
    case .audioMpeg: return 17
    case .audioMpg: return 18
    case .audioMp4: return 19
    case .audioMp4Latm: return 20
    case .audio3Gpp: return 21
    case .audioOgg: return 22
    case .audioUnspecified: return 23
    case .textVcard: return 24
    case .appPdf: return 25
    case .appTxt: return 26
    case .appHtml: return 27
    case .appDoc: return 28
    case .appDocx: return 29
    case .appPptx: return 30
    case .appPpt: return 31
    case .appXlsx: return 32
    case .appXls: return 33
    case .appApk: return 34
    case .appZip: return 35
    case .appJar: return 36
    case .appUnspecified: return 37
    case .calTextVcalendar: return 38
    case .calTextXvcalendar: return 39
    case .calTextCalendar: return 40
    case .calApplicationVcs: return 41
    case .calApplicationIcs: return 42
    case .calApplicationHbsvcs: return 43
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Conversations_MediaFormats] = [
    .unspecifiedType,
    .imageJpeg,
    .imageJpg,
    .imagePng,
    .imageGif,
    .imageWbmp,
    .imageXMsBmp,
    .imageUnspecified,
    .videoMp4,
    .video3G2,
    .video3Gpp,
    .videoWebm,
    .videoMkv,
    .videoUnspecified,
    .audioAac,
    .audioAmr,
    .audioMp3,
    .audioMpeg,
    .audioMpg,
    .audioMp4,
    .audioMp4Latm,
    .audio3Gpp,
    .audioOgg,
    .audioUnspecified,
    .textVcard,
    .appPdf,
    .appTxt,
    .appHtml,
    .appDoc,
    .appDocx,
    .appPptx,
    .appPpt,
    .appXlsx,
    .appXls,
    .appApk,
    .appZip,
    .appJar,
    .appUnspecified,
    .calTextVcalendar,
    .calTextXvcalendar,
    .calTextCalendar,
    .calApplicationVcs,
    .calApplicationIcs,
    .calApplicationHbsvcs,
  ]

}

public struct Conversations_Contact: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var participantID: String = String()

  public var name: String = String()

  public var number: Conversations_ContactNumber {
    get {return _number ?? Conversations_ContactNumber()}
    set {_number = newValue}
  }
  /// Returns true if `number` has been explicitly set.
  public var hasNumber: Bool {return self._number != nil}
  /// Clears the value of `number`. Subsequent reads from it will return its default value.
  public mutating func clearNumber() {self._number = nil}

  public var avatarHexColor: String = String()

  public var unknownBool: Bool = false

  public var contactID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _number: Conversations_ContactNumber? = nil
}

public struct Conversations_ContactNumber: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Might be 2 for contact and 7 for user input?
  public var mysteriousInt: Int32 = 0

  public var number: String = String()

  public var number2: String = String()

  public var formattedNumber: String {
    get {return _formattedNumber ?? String()}
    set {_formattedNumber = newValue}
  }
  /// Returns true if `formattedNumber` has been explicitly set.
  public var hasFormattedNumber: Bool {return self._formattedNumber != nil}
  /// Clears the value of `formattedNumber`. Subsequent reads from it will return its default value.
  public mutating func clearFormattedNumber() {self._formattedNumber = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _formattedNumber: String? = nil
}

public struct Conversations_SomeKindOfGroupID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String = String()

  public var nestedID: Conversations_SomeKindOfGroupID.NestedID {
    get {return _nestedID ?? Conversations_SomeKindOfGroupID.NestedID()}
    set {_nestedID = newValue}
  }
  /// Returns true if `nestedID` has been explicitly set.
  public var hasNestedID: Bool {return self._nestedID != nil}
  /// Clears the value of `nestedID`. Subsequent reads from it will return its default value.
  public mutating func clearNestedID() {self._nestedID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct NestedID: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _nestedID: Conversations_SomeKindOfGroupID.NestedID? = nil
}

public struct Conversations_AnotherMessageID: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: String = String()

  public var anotherID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Conversations_Message: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: String {
    get {return _storage._messageID}
    set {_uniqueStorage()._messageID = newValue}
  }

  public var msgType: Conversations_MsgType {
    get {return _storage._msgType ?? Conversations_MsgType()}
    set {_uniqueStorage()._msgType = newValue}
  }
  /// Returns true if `msgType` has been explicitly set.
  public var hasMsgType: Bool {return _storage._msgType != nil}
  /// Clears the value of `msgType`. Subsequent reads from it will return its default value.
  public mutating func clearMsgType() {_uniqueStorage()._msgType = nil}

  public var messageStatus: Conversations_MessageStatus {
    get {return _storage._messageStatus ?? Conversations_MessageStatus()}
    set {_uniqueStorage()._messageStatus = newValue}
  }
  /// Returns true if `messageStatus` has been explicitly set.
  public var hasMessageStatus: Bool {return _storage._messageStatus != nil}
  /// Clears the value of `messageStatus`. Subsequent reads from it will return its default value.
  public mutating func clearMessageStatus() {_uniqueStorage()._messageStatus = nil}

  /// check this
  public var timestamp: Int64 {
    get {return _storage._timestamp}
    set {_uniqueStorage()._timestamp = newValue}
  }

  public var conversationID: String {
    get {return _storage._conversationID}
    set {_uniqueStorage()._conversationID = newValue}
  }

  public var participantID: String {
    get {return _storage._participantID}
    set {_uniqueStorage()._participantID = newValue}
  }

  public var messageInfo: [Conversations_MessageInfo] {
    get {return _storage._messageInfo}
    set {_uniqueStorage()._messageInfo = newValue}
  }

  /// 1 = sms, 2 = downloaded mms, 3 = undownloaded mms, 4 = rcs?
  public var type: Int64 {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var tmpID: String {
    get {return _storage._tmpID}
    set {_uniqueStorage()._tmpID = newValue}
  }

  public var subject: String {
    get {return _storage._subject ?? String()}
    set {_uniqueStorage()._subject = newValue}
  }
  /// Returns true if `subject` has been explicitly set.
  public var hasSubject: Bool {return _storage._subject != nil}
  /// Clears the value of `subject`. Subsequent reads from it will return its default value.
  public mutating func clearSubject() {_uniqueStorage()._subject = nil}

  public var someInt: Int64 {
    get {return _storage._someInt}
    set {_uniqueStorage()._someInt = newValue}
  }

  public var reactions: [Conversations_ReactionEntry] {
    get {return _storage._reactions}
    set {_uniqueStorage()._reactions = newValue}
  }

  public var replyMessage: Conversations_ReplyMessage {
    get {return _storage._replyMessage ?? Conversations_ReplyMessage()}
    set {_uniqueStorage()._replyMessage = newValue}
  }
  /// Returns true if `replyMessage` has been explicitly set.
  public var hasReplyMessage: Bool {return _storage._replyMessage != nil}
  /// Clears the value of `replyMessage`. Subsequent reads from it will return its default value.
  public mutating func clearReplyMessage() {_uniqueStorage()._replyMessage = nil}

  public var someKindOfGroupID: Conversations_SomeKindOfGroupID {
    get {return _storage._someKindOfGroupID ?? Conversations_SomeKindOfGroupID()}
    set {_uniqueStorage()._someKindOfGroupID = newValue}
  }
  /// Returns true if `someKindOfGroupID` has been explicitly set.
  public var hasSomeKindOfGroupID: Bool {return _storage._someKindOfGroupID != nil}
  /// Clears the value of `someKindOfGroupID`. Subsequent reads from it will return its default value.
  public mutating func clearSomeKindOfGroupID() {_uniqueStorage()._someKindOfGroupID = nil}

  public var anotherMessageID: Conversations_AnotherMessageID {
    get {return _storage._anotherMessageID ?? Conversations_AnotherMessageID()}
    set {_uniqueStorage()._anotherMessageID = newValue}
  }
  /// Returns true if `anotherMessageID` has been explicitly set.
  public var hasAnotherMessageID: Bool {return _storage._anotherMessageID != nil}
  /// Clears the value of `anotherMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearAnotherMessageID() {_uniqueStorage()._anotherMessageID = nil}

  public var senderParticipant: Conversations_Participant {
    get {return _storage._senderParticipant ?? Conversations_Participant()}
    set {_uniqueStorage()._senderParticipant = newValue}
  }
  /// Returns true if `senderParticipant` has been explicitly set.
  public var hasSenderParticipant: Bool {return _storage._senderParticipant != nil}
  /// Clears the value of `senderParticipant`. Subsequent reads from it will return its default value.
  public mutating func clearSenderParticipant() {_uniqueStorage()._senderParticipant = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Conversations_ReactionEntry: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Conversations_ReactionData {
    get {return _data ?? Conversations_ReactionData()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var participantIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _data: Conversations_ReactionData? = nil
}

public struct Conversations_CustomEmojiData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var uuid: String = String()

  public var unknownInt4: Int32 {
    get {return _unknownInt4 ?? 0}
    set {_unknownInt4 = newValue}
  }
  /// Returns true if `unknownInt4` has been explicitly set.
  public var hasUnknownInt4: Bool {return self._unknownInt4 != nil}
  /// Clears the value of `unknownInt4`. Subsequent reads from it will return its default value.
  public mutating func clearUnknownInt4() {self._unknownInt4 = nil}

  public var innerData: Conversations_CustomEmojiData.Inner {
    get {return _innerData ?? Conversations_CustomEmojiData.Inner()}
    set {_innerData = newValue}
  }
  /// Returns true if `innerData` has been explicitly set.
  public var hasInnerData: Bool {return self._innerData != nil}
  /// Clears the value of `innerData`. Subsequent reads from it will return its default value.
  public mutating func clearInnerData() {self._innerData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Inner: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownString: String {
      get {return _unknownString ?? String()}
      set {_unknownString = newValue}
    }
    /// Returns true if `unknownString` has been explicitly set.
    public var hasUnknownString: Bool {return self._unknownString != nil}
    /// Clears the value of `unknownString`. Subsequent reads from it will return its default value.
    public mutating func clearUnknownString() {self._unknownString = nil}

    public var first: Conversations_CustomEmojiData.Inner.ImageData {
      get {return _first ?? Conversations_CustomEmojiData.Inner.ImageData()}
      set {_first = newValue}
    }
    /// Returns true if `first` has been explicitly set.
    public var hasFirst: Bool {return self._first != nil}
    /// Clears the value of `first`. Subsequent reads from it will return its default value.
    public mutating func clearFirst() {self._first = nil}

    public var second: Conversations_CustomEmojiData.Inner.WrappedImageData {
      get {return _second ?? Conversations_CustomEmojiData.Inner.WrappedImageData()}
      set {_second = newValue}
    }
    /// Returns true if `second` has been explicitly set.
    public var hasSecond: Bool {return self._second != nil}
    /// Clears the value of `second`. Subsequent reads from it will return its default value.
    public mutating func clearSecond() {self._second = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct ImageData: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var mimeType: String = String()

      public var uri: String = String()

      public var unknownInt3: Int32 {
        get {return _unknownInt3 ?? 0}
        set {_unknownInt3 = newValue}
      }
      /// Returns true if `unknownInt3` has been explicitly set.
      public var hasUnknownInt3: Bool {return self._unknownInt3 != nil}
      /// Clears the value of `unknownInt3`. Subsequent reads from it will return its default value.
      public mutating func clearUnknownInt3() {self._unknownInt3 = nil}

      public var unknownString5: String {
        get {return _unknownString5 ?? String()}
        set {_unknownString5 = newValue}
      }
      /// Returns true if `unknownString5` has been explicitly set.
      public var hasUnknownString5: Bool {return self._unknownString5 != nil}
      /// Clears the value of `unknownString5`. Subsequent reads from it will return its default value.
      public mutating func clearUnknownString5() {self._unknownString5 = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _unknownInt3: Int32? = nil
      fileprivate var _unknownString5: String? = nil
    }

    public struct WrappedImageData: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var data: Conversations_CustomEmojiData.Inner.WrappedImageData.ImageData {
        get {return _data ?? Conversations_CustomEmojiData.Inner.WrappedImageData.ImageData()}
        set {_data = newValue}
      }
      /// Returns true if `data` has been explicitly set.
      public var hasData: Bool {return self._data != nil}
      /// Clears the value of `data`. Subsequent reads from it will return its default value.
      public mutating func clearData() {self._data = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct ImageData: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var unknownInt1: Int32 = 0

        public var mimeType: String = String()

        public var uri: String = String()

        public var width: Int32 = 0

        public var height: Int32 = 0

        public var unknownInt7: Int32 {
          get {return _unknownInt7 ?? 0}
          set {_unknownInt7 = newValue}
        }
        /// Returns true if `unknownInt7` has been explicitly set.
        public var hasUnknownInt7: Bool {return self._unknownInt7 != nil}
        /// Clears the value of `unknownInt7`. Subsequent reads from it will return its default value.
        public mutating func clearUnknownInt7() {self._unknownInt7 = nil}

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}

        fileprivate var _unknownInt7: Int32? = nil
      }

      public init() {}

      fileprivate var _data: Conversations_CustomEmojiData.Inner.WrappedImageData.ImageData? = nil
    }

    public init() {}

    fileprivate var _unknownString: String? = nil
    fileprivate var _first: Conversations_CustomEmojiData.Inner.ImageData? = nil
    fileprivate var _second: Conversations_CustomEmojiData.Inner.WrappedImageData? = nil
  }

  public init() {}

  fileprivate var _unknownInt4: Int32? = nil
  fileprivate var _innerData: Conversations_CustomEmojiData.Inner? = nil
}

public struct Conversations_ReactionData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unicode: String = String()

  public var type: Conversations_EmojiType = .reactionTypeUnspecified

  public var customEmoji: Conversations_CustomEmojiData {
    get {return _customEmoji ?? Conversations_CustomEmojiData()}
    set {_customEmoji = newValue}
  }
  /// Returns true if `customEmoji` has been explicitly set.
  public var hasCustomEmoji: Bool {return self._customEmoji != nil}
  /// Clears the value of `customEmoji`. Subsequent reads from it will return its default value.
  public mutating func clearCustomEmoji() {self._customEmoji = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _customEmoji: Conversations_CustomEmojiData? = nil
}

public struct Conversations_EmojiMeta: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var emojiMetaData: [Conversations_EmojiMetaData] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Conversations_EmojiMetaData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unicode: String = String()

  public var names: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Conversations_ReplyMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageID: String = String()

  /// might be participantID
  public var conversationID: String = String()

  public var replyMessageData: Conversations_ReplyMessageData {
    get {return _replyMessageData ?? Conversations_ReplyMessageData()}
    set {_replyMessageData = newValue}
  }
  /// Returns true if `replyMessageData` has been explicitly set.
  public var hasReplyMessageData: Bool {return self._replyMessageData != nil}
  /// Clears the value of `replyMessageData`. Subsequent reads from it will return its default value.
  public mutating func clearReplyMessageData() {self._replyMessageData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _replyMessageData: Conversations_ReplyMessageData? = nil
}

public struct Conversations_ReplyMessageData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Conversations_MessageInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var actionMessageID: String {
    get {return _actionMessageID ?? String()}
    set {_actionMessageID = newValue}
  }
  /// Returns true if `actionMessageID` has been explicitly set.
  public var hasActionMessageID: Bool {return self._actionMessageID != nil}
  /// Clears the value of `actionMessageID`. Subsequent reads from it will return its default value.
  public mutating func clearActionMessageID() {self._actionMessageID = nil}

  public var data: Conversations_MessageInfo.OneOf_Data? = nil

  public var messageContent: Conversations_MessageContent {
    get {
      if case .messageContent(let v)? = data {return v}
      return Conversations_MessageContent()
    }
    set {data = .messageContent(newValue)}
  }

  public var mediaContent: Conversations_MediaContent {
    get {
      if case .mediaContent(let v)? = data {return v}
      return Conversations_MediaContent()
    }
    set {data = .mediaContent(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable, Sendable {
    case messageContent(Conversations_MessageContent)
    case mediaContent(Conversations_MediaContent)

  }

  public init() {}

  fileprivate var _actionMessageID: String? = nil
}

public struct Conversations_MediaContent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var format: Conversations_MediaFormats = .unspecifiedType

  public var mediaID: String = String()

  public var mediaName: String = String()

  public var size: Int64 = 0

  public var dimensions: Conversations_Dimensions {
    get {return _dimensions ?? Conversations_Dimensions()}
    set {_dimensions = newValue}
  }
  /// Returns true if `dimensions` has been explicitly set.
  public var hasDimensions: Bool {return self._dimensions != nil}
  /// Clears the value of `dimensions`. Subsequent reads from it will return its default value.
  public mutating func clearDimensions() {self._dimensions = nil}

  public var mediaData: Data = Data()

  public var thumbnailMediaID: String = String()

  public var decryptionKey: Data = Data()

  public var thumbnailDecryptionKey: Data = Data()

  public var mimeType: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _dimensions: Conversations_Dimensions? = nil
}

public struct Conversations_Dimensions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var width: Int64 = 0

  public var height: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Conversations_MessageContent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var content: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Conversations_MsgType: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Conversations_MessageStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: Conversations_MessageStatusType = .statusUnknown

  public var subCode: Int64 = 0

  public var errMsg: String = String()

  public var statusText: String = String()

  public var thirdCode: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Conversations_Conversation: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var conversationID: String {
    get {return _storage._conversationID}
    set {_uniqueStorage()._conversationID = newValue}
  }

  public var name: String {
    get {return _storage._name}
    set {_uniqueStorage()._name = newValue}
  }

  public var latestMessage: Conversations_LatestMessage {
    get {return _storage._latestMessage ?? Conversations_LatestMessage()}
    set {_uniqueStorage()._latestMessage = newValue}
  }
  /// Returns true if `latestMessage` has been explicitly set.
  public var hasLatestMessage: Bool {return _storage._latestMessage != nil}
  /// Clears the value of `latestMessage`. Subsequent reads from it will return its default value.
  public mutating func clearLatestMessage() {_uniqueStorage()._latestMessage = nil}

  public var lastMessageTimestamp: Int64 {
    get {return _storage._lastMessageTimestamp}
    set {_uniqueStorage()._lastMessageTimestamp = newValue}
  }

  public var unread: Bool {
    get {return _storage._unread}
    set {_uniqueStorage()._unread = newValue}
  }

  /// not certain
  public var isGroupChat: Bool {
    get {return _storage._isGroupChat}
    set {_uniqueStorage()._isGroupChat = newValue}
  }

  public var defaultOutgoingID: String {
    get {return _storage._defaultOutgoingID}
    set {_uniqueStorage()._defaultOutgoingID = newValue}
  }

  public var status: Conversations_ConversationStatus {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  public var readOnly: Bool {
    get {return _storage._readOnly}
    set {_uniqueStorage()._readOnly = newValue}
  }

  public var avatarHexColor: String {
    get {return _storage._avatarHexColor}
    set {_uniqueStorage()._avatarHexColor = newValue}
  }

  public var latestMessageID: String {
    get {return _storage._latestMessageID}
    set {_uniqueStorage()._latestMessageID = newValue}
  }

  public var sendMode: Conversations_ConversationSendMode {
    get {return _storage._sendMode}
    set {_uniqueStorage()._sendMode = newValue}
  }

  public var participants: [Conversations_Participant] {
    get {return _storage._participants}
    set {_uniqueStorage()._participants = newValue}
  }

  /// participant ids excluding me
  public var otherParticipants: [String] {
    get {return _storage._otherParticipants}
    set {_uniqueStorage()._otherParticipants = newValue}
  }

  public var type: Conversations_ConversationType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  public var subType: Bool {
    get {return _storage._subType}
    set {_uniqueStorage()._subType = newValue}
  }

  public var pinned: Bool {
    get {return _storage._pinned}
    set {_uniqueStorage()._pinned = newValue}
  }

  /// set to lastMessageTimestamp + 1000 when marking as unread?
  public var unknownTimestamp: Int64 {
    get {return _storage._unknownTimestamp}
    set {_uniqueStorage()._unknownTimestamp = newValue}
  }

  public var thirdType: Bool {
    get {return _storage._thirdType}
    set {_uniqueStorage()._thirdType = newValue}
  }

  public var someKindOfGroupID: Conversations_SomeKindOfGroupID {
    get {return _storage._someKindOfGroupID ?? Conversations_SomeKindOfGroupID()}
    set {_uniqueStorage()._someKindOfGroupID = newValue}
  }
  /// Returns true if `someKindOfGroupID` has been explicitly set.
  public var hasSomeKindOfGroupID: Bool {return _storage._someKindOfGroupID != nil}
  /// Clears the value of `someKindOfGroupID`. Subsequent reads from it will return its default value.
  public mutating func clearSomeKindOfGroupID() {_uniqueStorage()._someKindOfGroupID = nil}

  public var simCard: Settings_SIMCard {
    get {return _storage._simCard ?? Settings_SIMCard()}
    set {_uniqueStorage()._simCard = newValue}
  }
  /// Returns true if `simCard` has been explicitly set.
  public var hasSimCard: Bool {return _storage._simCard != nil}
  /// Clears the value of `simCard`. Subsequent reads from it will return its default value.
  public mutating func clearSimCard() {_uniqueStorage()._simCard = nil}

  public var latestMessageAnoherID: Conversations_AnotherMessageID {
    get {return _storage._latestMessageAnoherID ?? Conversations_AnotherMessageID()}
    set {_uniqueStorage()._latestMessageAnoherID = newValue}
  }
  /// Returns true if `latestMessageAnoherID` has been explicitly set.
  public var hasLatestMessageAnoherID: Bool {return _storage._latestMessageAnoherID != nil}
  /// Clears the value of `latestMessageAnoherID`. Subsequent reads from it will return its default value.
  public mutating func clearLatestMessageAnoherID() {_uniqueStorage()._latestMessageAnoherID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Conversations_Participant: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Conversations_SmallInfo {
    get {return _id ?? Conversations_SmallInfo()}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  public var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  public mutating func clearID() {self._id = nil}

  public var firstName: String = String()

  public var fullName: String = String()

  public var avatarHexColor: String = String()

  public var isMe: Bool = false

  public var simPayload: Settings_SIMPayload {
    get {return _simPayload ?? Settings_SIMPayload()}
    set {_simPayload = newValue}
  }
  /// Returns true if `simPayload` has been explicitly set.
  public var hasSimPayload: Bool {return self._simPayload != nil}
  /// Clears the value of `simPayload`. Subsequent reads from it will return its default value.
  public mutating func clearSimPayload() {self._simPayload = nil}

  public var isVisible: Bool = false

  public var contactID: String = String()

  public var bs: Int64 = 0

  public var formattedNumber: String = String()

  public var someInt1: Int64 = 0

  public var someInt2: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _id: Conversations_SmallInfo? = nil
  fileprivate var _simPayload: Settings_SIMPayload? = nil
}

public struct Conversations_SmallInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Conversations_IdentifierType = .unknown

  public var number: String = String()

  public var participantID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Conversations_LatestMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var displayContent: String = String()

  public var fromMe: Int64 = 0

  public var displayName: String = String()

  public var latestMessageStatus: Conversations_LatestMessageStatus {
    get {return _latestMessageStatus ?? Conversations_LatestMessageStatus()}
    set {_latestMessageStatus = newValue}
  }
  /// Returns true if `latestMessageStatus` has been explicitly set.
  public var hasLatestMessageStatus: Bool {return self._latestMessageStatus != nil}
  /// Clears the value of `latestMessageStatus`. Subsequent reads from it will return its default value.
  public mutating func clearLatestMessageStatus() {self._latestMessageStatus = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _latestMessageStatus: Conversations_LatestMessageStatus? = nil
}

public struct Conversations_LatestMessageStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status2: Int64 = 0

  public var status: Conversations_MessageStatusType = .statusUnknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Conversations_Muted: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isMuted: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "conversations"

extension Conversations_EmojiType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0REACTION_TYPE_UNSPECIFIED\0\u{1}LIKE\0\u{1}LOVE\0\u{1}LAUGH\0\u{1}SURPRISED\0\u{1}SAD\0\u{1}ANGRY\0\u{1}DISLIKE\0\u{1}CUSTOM\0\u{1}QUESTIONING\0\u{1}CRYING_FACE\0\u{1}POUTING_FACE\0\u{1}RED_HEART\0\u{1}EMOTIFY\0")
}

extension Conversations_IdentifierType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN\0\u{1}PHONE\0\u{1}EMAIL\0")
}

extension Conversations_ConversationSendMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SEND_MODE_AUTO\0\u{1}SEND_MODE_XMS\0\u{1}SEND_MODE_XMS_LATCH\0")
}

extension Conversations_ConversationType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN_CONVERSATION_TYPE\0\u{1}SMS\0\u{1}RCS\0")
}

extension Conversations_MessageStatusType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0STATUS_UNKNOWN\0\u{1}OUTGOING_COMPLETE\0\u{1}OUTGOING_DELIVERED\0\u{1}OUTGOING_DRAFT\0\u{1}OUTGOING_YET_TO_SEND\0\u{1}OUTGOING_SENDING\0\u{1}OUTGOING_RESENDING\0\u{1}OUTGOING_AWAITING_RETRY\0\u{1}OUTGOING_FAILED_GENERIC\0\u{1}OUTGOING_FAILED_EMERGENCY_NUMBER\0\u{1}OUTGOING_SEND_AFTER_PROCESSING\0\u{1}OUTGOING_DISPLAYED\0\u{1}OUTGOING_CANCELED\0\u{1}OUTGOING_FAILED_TOO_LARGE\0\u{1}OUTGOING_NOT_DELIVERED_YET\0\u{1}OUTGOING_REVOCATION_PENDING\0\u{1}OUTGOING_SCHEDULED\0\u{1}OUTGOING_FAILED_RECIPIENT_LOST_RCS\0\u{1}OUTGOING_FAILED_NO_RETRY_NO_FALLBACK\0\u{1}OUTGOING_FAILED_RECIPIENT_DID_NOT_DECRYPT\0\u{1}OUTGOING_VALIDATING\0\u{1}OUTGOING_FAILED_RECIPIENT_LOST_ENCRYPTION\0\u{1}OUTGOING_FAILED_RECIPIENT_DID_NOT_DECRYPT_NO_MORE_RETRY\0\u{2}N\u{1}INCOMING_COMPLETE\0\u{1}INCOMING_YET_TO_MANUAL_DOWNLOAD\0\u{1}INCOMING_RETRYING_MANUAL_DOWNLOAD\0\u{1}INCOMING_MANUAL_DOWNLOADING\0\u{1}INCOMING_RETRYING_AUTO_DOWNLOAD\0\u{1}INCOMING_AUTO_DOWNLOADING\0\u{1}INCOMING_DOWNLOAD_FAILED\0\u{1}INCOMING_EXPIRED_OR_NOT_AVAILABLE\0\u{1}INCOMING_DELIVERED\0\u{1}INCOMING_DISPLAYED\0\u{1}INCOMING_DOWNLOAD_CANCELED\0\u{1}INCOMING_DOWNLOAD_FAILED_TOO_LARGE\0\u{1}INCOMING_DOWNLOAD_FAILED_SIM_HAS_NO_DATA\0\u{1}INCOMING_FAILED_TO_DECRYPT\0\u{1}INCOMING_DECRYPTION_ABORTED\0\u{2}V\u{1}TOMBSTONE_PARTICIPANT_JOINED\0\u{1}TOMBSTONE_PARTICIPANT_LEFT\0\u{1}TOMBSTONE_SELF_LEFT\0\u{1}TOMBSTONE_RCS_GROUP_CREATED\0\u{1}TOMBSTONE_MMS_GROUP_CREATED\0\u{1}TOMBSTONE_SMS_BROADCAST_CREATED\0\u{1}TOMBSTONE_ONE_ON_ONE_SMS_CREATED\0\u{1}TOMBSTONE_ONE_ON_ONE_RCS_CREATED\0\u{1}TOMBSTONE_SWITCH_TO_GROUP_MMS\0\u{1}TOMBSTONE_SWITCH_TO_BROADCAST_SMS\0\u{1}TOMBSTONE_SHOW_LINK_PREVIEWS\0\u{1}TOMBSTONE_GROUP_RENAMED_LOCAL\0\u{1}TOMBSTONE_VERIFIED_SMS_APPLICABLE\0\u{1}TOMBSTONE_ENCRYPTED_ONE_ON_ONE_RCS_CREATED\0\u{1}TOMBSTONE_PROTOCOL_SWITCH_TO_TEXT\0\u{1}TOMBSTONE_PROTOCOL_SWITCH_TO_RCS\0\u{1}TOMBSTONE_PROTOCOL_SWITCH_TO_ENCRYPTED_RCS\0\u{1}TOMBSTONE_GROUP_RENAMED_GLOBAL\0\u{1}TOMBSTONE_GROUP_NAME_CLEARED_GLOBAL\0\u{1}TOMBSTONE_PROTOCOL_SWITCH_TO_ENCRYPTED_RCS_INFO\0\u{1}TOMBSTONE_SELF_REMOVED_FROM_GROUP\0\u{1}MESSAGE_STATUS_TOMBSTONE_PARTICIPANT_REMOVED_FROM_GROUP\0\u{1}MESSAGE_STATUS_TOMBSTONE_SMS_NORM_PARTICIPANT_UPGRADED\0\u{1}MESSAGE_STATUS_TOMBSTONE_RCS_NORM_PARTICIPANT_UPGRADED\0\u{1}MESSAGE_STATUS_TOMBSTONE_ENCRYPTED_RCS_NORM_PARTICIPANT_UPGRADED\0\u{1}MESSAGE_STATUS_TOMBSTONE_ENCRYPTED_GROUP_PARTICIPANT_JOINED\0\u{1}MESSAGE_STATUS_TOMBSTONE_ENCRYPTED_GROUP_PARTICIPANT_JOINED_INFO\0\u{1}MESSAGE_STATUS_TOMBSTONE_ENCRYPTED_GROUP_PARTICIPANT_LEFT\0\u{1}MESSAGE_STATUS_TOMBSTONE_ENCRYPTED_GROUP_SELF_LEFT\0\u{1}MESSAGE_STATUS_TOMBSTONE_ENCRYPTED_GROUP_CREATED\0\u{1}MESSAGE_STATUS_TOMBSTONE_SELF_REMOVED_FROM_ENCRYPTED_GROUP\0\u{1}MESSAGE_STATUS_TOMBSTONE_PARTICIPANT_REMOVED_FROM_ENCRYPTED_GROUP\0\u{1}MESSAGE_STATUS_TOMBSTONE_SUGGESTION_SHORTCUT_STAR_TOOLSTONE\0\u{1}MESSAGE_STATUS_TOMBSTONE_GROUP_PROTOCOL_SWITCH_RCS_TO_E2EE\0\u{1}MESSAGE_STATUS_TOMBSTONE_GROUP_PROTOCOL_SWITCH_E2EE_TO_RCS\0\u{1}MESSAGE_STATUS_TOMBSTONE_PROTOCOL_SWITCH_TEXT_TO_E2EE\0\u{1}MESSAGE_STATUS_TOMBSTONE_PROTOCOL_SWITCH_E2EE_TO_TEXT\0\u{1}MESSAGE_STATUS_TOMBSTONE_PROTOCOL_SWITCH_RCS_TO_E2EE\0\u{1}MESSAGE_STATUS_TOMBSTONE_PROTOCOL_SWITCH_E2EE_TO_RCS\0\u{1}MESSAGE_STATUS_TOMBSTONE_SATELLITE_EDUCATION\0\u{1}MESSAGE_STATUS_TOMBSTONE_RBM_SIM_SWITCH\0\u{1}MESSAGE_STATUS_TOMBSTONE_RBM_PRIVACY_NOTICE\0\u{1}MESSAGE_STATUS_TOMBSTONE_PENPAL_CONVERSATION_NOTICE\0\u{1}MESSAGE_STATUS_TOMBSTONE_MEET_OTHER_PARTICIPANT_REACHABLE\0\u{1}MESSAGE_STATUS_TOMBSTONE_MISSED_VIDEO_CALL\0\u{1}MESSAGE_STATUS_TOMBSTONE_PARTICIPANT_THEME_CHANGE\0\u{1}MESSAGE_STATUS_TOMBSTONE_SATELLITE_END_OF_EMERGENCY_SUCCESS_HELP_STILL_NEEDED\0\u{1}MESSAGE_STATUS_TOMBSTONE_SATELLITE_END_OF_EMERGENCY_SUCCESS_HELP_NO_LONGER_NEEDED\0\u{1}MESSAGE_STATUS_TOMBSTONE_SATELLITE_END_OF_EMERGENCY_FAILURE_HELP_STILL_NEEDED\0\u{1}MESSAGE_STATUS_TOMBSTONE_SATELLITE_END_OF_EMERGENCY_FAILURE_HELP_NO_LONGER_NEEDED\0\u{1}MESSAGE_STATUS_TOMBSTONE_SATELLITE_END_OF_EMERGENCY_UNEXPECTED_END\0\u{1}MESSAGE_STATUS_TOMBSTONE_SATELLITE_MESSAGING_TOOLSTONE\0\u{1}MESSAGE_STATUS_TOMBSTONE_GROUP_PROTOCOL_SWITCH_E2EE_TO_MMS\0\u{1}MESSAGE_STATUS_TOMBSTONE_PENPAL_PROACTIVE_MESSAGE_NOTICE\0\u{1}MESSAGE_STATUS_TOMBSTONE_SUGGESTION_POSSIBLE_SCAM_TOOLSTONE\0\u{1}MESSAGE_STATUS_TOMBSTONE_CHATBOT_UNSUBSCRIBE_SENT\0\u{1}MESSAGE_STATUS_TOMBSTONE_CHATBOT_SUBSCRIBE_SENT\0\u{1}MESSAGE_STATUS_TOMBSTONE_CHATBOT_UNSUBSCRIBE_CONFIRMED\0\u{1}MESSAGE_STATUS_TOMBSTONE_CHATBOT_SUBSCRIBE_CONFIRMED\0\u{1}MESSAGE_STATUS_TOMBSTONE_ACTIVE_SELF_IDENTITY_CHANGED\0\u{1}MESSAGE_STATUS_TOMBSTONE_GROUP_ICON_CHANGED_GLOBAL\0\u{1}MESSAGE_STATUS_TOMBSTONE_GROUP_ICON_CLEARED_GLOBAL\0\u{1}MESSAGE_STATUS_TOMBSTONE_CHATBOT_UNSUBSCRIBE_ERROR\0\u{1}MESSAGE_STATUS_TOMBSTONE_CHATBOT_SUBSCRIBE_ERROR\0\u{1}MESSAGE_STATUS_TOMBSTONE_EMERGENCY_CONVERSATION_CREATED\0\u{1}MESSAGE_STATUS_TOMBSTONE_SENSITIVE_CONTENT_WARNING_TOOLSTONE\0\u{1}MESSAGE_STATUS_TOMBSTONE_CHATBOT_UNSUBSCRIBE_CONFIRMED_NO_LINK\0\u{1}MESSAGE_STATUS_TOMBSTONE_CHATBOT_SUBSCRIBE_CONFIRMED_NO_LINK\0\u{1}MESSAGE_STATUS_TOMBSTONE_EMERGENCY_QUESTIONNAIRE\0\u{1}MESSAGE_STATUS_TOMBSTONE_CHATBOT_UNSUBSCRIBE_SENT_NO_LINK\0\u{1}MESSAGE_STATUS_TOMBSTONE_CHATBOT_SUBSCRIBE_SENT_NO_LINK\0\u{1}MESSAGE_STATUS_TOMBSTONE_RCS_GROUP_JOINED_BY_LINK\0\u{1}MESSAGE_STATUS_TOMBSTONE_INVITE_LINK_ENABLED\0\u{1}MESSAGE_STATUS_TOMBSTONE_INVITE_LINK_DISABLED\0\u{1}MESSAGE_STATUS_TOMBSTONE_INVITE_LINK_RESET_MANUALLY\0\u{1}MESSAGE_STATUS_TOMBSTONE_INVITE_LINK_RESET_AUTOMATICALLY\0\u{2}\u{19}MESSAGE_DELETED\0")
}

extension Conversations_ConversationStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN_CONVERSATION_STATUS\0\u{1}ACTIVE\0\u{1}ARCHIVED\0\u{1}DELETED\0\u{1}KEEP_ARCHIVED\0\u{1}SPAM_FOLDER\0\u{1}BLOCKED_FOLDER\0\u{1}CROSS_COUNTRY_FOLDER\0")
}

extension Conversations_MediaFormats: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNSPECIFIED_TYPE\0\u{1}IMAGE_JPEG\0\u{1}IMAGE_JPG\0\u{1}IMAGE_PNG\0\u{1}IMAGE_GIF\0\u{1}IMAGE_WBMP\0\u{1}IMAGE_X_MS_BMP\0\u{1}IMAGE_UNSPECIFIED\0\u{1}VIDEO_MP4\0\u{1}VIDEO_3G2\0\u{1}VIDEO_3GPP\0\u{1}VIDEO_WEBM\0\u{1}VIDEO_MKV\0\u{1}VIDEO_UNSPECIFIED\0\u{1}AUDIO_AAC\0\u{1}AUDIO_AMR\0\u{1}AUDIO_MP3\0\u{1}AUDIO_MPEG\0\u{1}AUDIO_MPG\0\u{1}AUDIO_MP4\0\u{1}AUDIO_MP4_LATM\0\u{1}AUDIO_3GPP\0\u{1}AUDIO_OGG\0\u{1}AUDIO_UNSPECIFIED\0\u{1}TEXT_VCARD\0\u{1}APP_PDF\0\u{1}APP_TXT\0\u{1}APP_HTML\0\u{1}APP_DOC\0\u{1}APP_DOCX\0\u{1}APP_PPTX\0\u{1}APP_PPT\0\u{1}APP_XLSX\0\u{1}APP_XLS\0\u{1}APP_APK\0\u{1}APP_ZIP\0\u{1}APP_JAR\0\u{1}APP_UNSPECIFIED\0\u{1}CAL_TEXT_VCALENDAR\0\u{1}CAL_TEXT_XVCALENDAR\0\u{1}CAL_TEXT_CALENDAR\0\u{1}CAL_APPLICATION_VCS\0\u{1}CAL_APPLICATION_ICS\0\u{1}CAL_APPLICATION_HBSVCS\0")
}

extension Conversations_Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Contact"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}participantID\0\u{1}name\0\u{1}number\0\u{2}\u{4}avatarHexColor\0\u{2}\u{3}unknownBool\0\u{1}contactID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.participantID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._number) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.avatarHexColor) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self.unknownBool) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.contactID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.participantID.isEmpty {
      try visitor.visitSingularStringField(value: self.participantID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    try { if let v = self._number {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.avatarHexColor.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarHexColor, fieldNumber: 7)
    }
    if self.unknownBool != false {
      try visitor.visitSingularBoolField(value: self.unknownBool, fieldNumber: 10)
    }
    if !self.contactID.isEmpty {
      try visitor.visitSingularStringField(value: self.contactID, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_Contact, rhs: Conversations_Contact) -> Bool {
    if lhs.participantID != rhs.participantID {return false}
    if lhs.name != rhs.name {return false}
    if lhs._number != rhs._number {return false}
    if lhs.avatarHexColor != rhs.avatarHexColor {return false}
    if lhs.unknownBool != rhs.unknownBool {return false}
    if lhs.contactID != rhs.contactID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_ContactNumber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ContactNumber"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mysteriousInt\0\u{1}number\0\u{1}number2\0\u{1}formattedNumber\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.mysteriousInt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.number) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.number2) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._formattedNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.mysteriousInt != 0 {
      try visitor.visitSingularInt32Field(value: self.mysteriousInt, fieldNumber: 1)
    }
    if !self.number.isEmpty {
      try visitor.visitSingularStringField(value: self.number, fieldNumber: 2)
    }
    if !self.number2.isEmpty {
      try visitor.visitSingularStringField(value: self.number2, fieldNumber: 3)
    }
    try { if let v = self._formattedNumber {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_ContactNumber, rhs: Conversations_ContactNumber) -> Bool {
    if lhs.mysteriousInt != rhs.mysteriousInt {return false}
    if lhs.number != rhs.number {return false}
    if lhs.number2 != rhs.number2 {return false}
    if lhs._formattedNumber != rhs._formattedNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_SomeKindOfGroupID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SomeKindOfGroupID"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conversationID\0\u{1}nestedID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._nestedID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 1)
    }
    try { if let v = self._nestedID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_SomeKindOfGroupID, rhs: Conversations_SomeKindOfGroupID) -> Bool {
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs._nestedID != rhs._nestedID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_SomeKindOfGroupID.NestedID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Conversations_SomeKindOfGroupID.protoMessageName + ".NestedID"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_SomeKindOfGroupID.NestedID, rhs: Conversations_SomeKindOfGroupID.NestedID) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_AnotherMessageID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AnotherMessageID"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}messageID\0\u{1}anotherID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.anotherID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if !self.anotherID.isEmpty {
      try visitor.visitSingularStringField(value: self.anotherID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_AnotherMessageID, rhs: Conversations_AnotherMessageID) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.anotherID != rhs.anotherID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Message"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}messageID\0\u{2}\u{2}msgType\0\u{1}messageStatus\0\u{1}timestamp\0\u{2}\u{2}conversationID\0\u{2}\u{2}participantID\0\u{1}messageInfo\0\u{1}type\0\u{1}tmpID\0\u{2}\u{2}subject\0\u{2}\u{2}someInt\0\u{2}\u{3}reactions\0\u{2}\u{2}replyMessage\0\u{2}\u{2}someKindOfGroupID\0\u{1}anotherMessageID\0\u{1}senderParticipant\0")

  fileprivate class _StorageClass {
    var _messageID: String = String()
    var _msgType: Conversations_MsgType? = nil
    var _messageStatus: Conversations_MessageStatus? = nil
    var _timestamp: Int64 = 0
    var _conversationID: String = String()
    var _participantID: String = String()
    var _messageInfo: [Conversations_MessageInfo] = []
    var _type: Int64 = 0
    var _tmpID: String = String()
    var _subject: String? = nil
    var _someInt: Int64 = 0
    var _reactions: [Conversations_ReactionEntry] = []
    var _replyMessage: Conversations_ReplyMessage? = nil
    var _someKindOfGroupID: Conversations_SomeKindOfGroupID? = nil
    var _anotherMessageID: Conversations_AnotherMessageID? = nil
    var _senderParticipant: Conversations_Participant? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _messageID = source._messageID
      _msgType = source._msgType
      _messageStatus = source._messageStatus
      _timestamp = source._timestamp
      _conversationID = source._conversationID
      _participantID = source._participantID
      _messageInfo = source._messageInfo
      _type = source._type
      _tmpID = source._tmpID
      _subject = source._subject
      _someInt = source._someInt
      _reactions = source._reactions
      _replyMessage = source._replyMessage
      _someKindOfGroupID = source._someKindOfGroupID
      _anotherMessageID = source._anotherMessageID
      _senderParticipant = source._senderParticipant
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._messageID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._msgType) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._messageStatus) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._timestamp) }()
        case 7: try { try decoder.decodeSingularStringField(value: &_storage._conversationID) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._participantID) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._messageInfo) }()
        case 11: try { try decoder.decodeSingularInt64Field(value: &_storage._type) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._tmpID) }()
        case 14: try { try decoder.decodeSingularStringField(value: &_storage._subject) }()
        case 16: try { try decoder.decodeSingularInt64Field(value: &_storage._someInt) }()
        case 19: try { try decoder.decodeRepeatedMessageField(value: &_storage._reactions) }()
        case 21: try { try decoder.decodeSingularMessageField(value: &_storage._replyMessage) }()
        case 23: try { try decoder.decodeSingularMessageField(value: &_storage._someKindOfGroupID) }()
        case 24: try { try decoder.decodeSingularMessageField(value: &_storage._anotherMessageID) }()
        case 25: try { try decoder.decodeSingularMessageField(value: &_storage._senderParticipant) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._messageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._messageID, fieldNumber: 1)
      }
      try { if let v = _storage._msgType {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._messageStatus {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._timestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._timestamp, fieldNumber: 5)
      }
      if !_storage._conversationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._conversationID, fieldNumber: 7)
      }
      if !_storage._participantID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._participantID, fieldNumber: 9)
      }
      if !_storage._messageInfo.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._messageInfo, fieldNumber: 10)
      }
      if _storage._type != 0 {
        try visitor.visitSingularInt64Field(value: _storage._type, fieldNumber: 11)
      }
      if !_storage._tmpID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._tmpID, fieldNumber: 12)
      }
      try { if let v = _storage._subject {
        try visitor.visitSingularStringField(value: v, fieldNumber: 14)
      } }()
      if _storage._someInt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._someInt, fieldNumber: 16)
      }
      if !_storage._reactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._reactions, fieldNumber: 19)
      }
      try { if let v = _storage._replyMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._someKindOfGroupID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._anotherMessageID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._senderParticipant {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_Message, rhs: Conversations_Message) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._messageID != rhs_storage._messageID {return false}
        if _storage._msgType != rhs_storage._msgType {return false}
        if _storage._messageStatus != rhs_storage._messageStatus {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._conversationID != rhs_storage._conversationID {return false}
        if _storage._participantID != rhs_storage._participantID {return false}
        if _storage._messageInfo != rhs_storage._messageInfo {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._tmpID != rhs_storage._tmpID {return false}
        if _storage._subject != rhs_storage._subject {return false}
        if _storage._someInt != rhs_storage._someInt {return false}
        if _storage._reactions != rhs_storage._reactions {return false}
        if _storage._replyMessage != rhs_storage._replyMessage {return false}
        if _storage._someKindOfGroupID != rhs_storage._someKindOfGroupID {return false}
        if _storage._anotherMessageID != rhs_storage._anotherMessageID {return false}
        if _storage._senderParticipant != rhs_storage._senderParticipant {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_ReactionEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReactionEntry"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}data\0\u{1}participantIDs\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.participantIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.participantIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.participantIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_ReactionEntry, rhs: Conversations_ReactionEntry) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.participantIds != rhs.participantIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_CustomEmojiData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CustomEmojiData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}uuid\0\u{2}\u{3}unknownInt4\0\u{2}`\u{1}innerData\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.uuid) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self._unknownInt4) }()
      case 100: try { try decoder.decodeSingularMessageField(value: &self._innerData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.uuid.isEmpty {
      try visitor.visitSingularStringField(value: self.uuid, fieldNumber: 1)
    }
    try { if let v = self._unknownInt4 {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._innerData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_CustomEmojiData, rhs: Conversations_CustomEmojiData) -> Bool {
    if lhs.uuid != rhs.uuid {return false}
    if lhs._unknownInt4 != rhs._unknownInt4 {return false}
    if lhs._innerData != rhs._innerData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_CustomEmojiData.Inner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Conversations_CustomEmojiData.protoMessageName + ".Inner"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}d\u{1}unknownString\0\u{1}first\0\u{1}second\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 100: try { try decoder.decodeSingularStringField(value: &self._unknownString) }()
      case 101: try { try decoder.decodeSingularMessageField(value: &self._first) }()
      case 102: try { try decoder.decodeSingularMessageField(value: &self._second) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._unknownString {
      try visitor.visitSingularStringField(value: v, fieldNumber: 100)
    } }()
    try { if let v = self._first {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    } }()
    try { if let v = self._second {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_CustomEmojiData.Inner, rhs: Conversations_CustomEmojiData.Inner) -> Bool {
    if lhs._unknownString != rhs._unknownString {return false}
    if lhs._first != rhs._first {return false}
    if lhs._second != rhs._second {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_CustomEmojiData.Inner.ImageData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Conversations_CustomEmojiData.Inner.protoMessageName + ".ImageData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mimeType\0\u{1}uri\0\u{1}unknownInt3\0\u{2}\u{2}unknownString5\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self._unknownInt3) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._unknownString5) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 1)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 2)
    }
    try { if let v = self._unknownInt3 {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._unknownString5 {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_CustomEmojiData.Inner.ImageData, rhs: Conversations_CustomEmojiData.Inner.ImageData) -> Bool {
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs._unknownInt3 != rhs._unknownInt3 {return false}
    if lhs._unknownString5 != rhs._unknownString5 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_CustomEmojiData.Inner.WrappedImageData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Conversations_CustomEmojiData.Inner.protoMessageName + ".WrappedImageData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_CustomEmojiData.Inner.WrappedImageData, rhs: Conversations_CustomEmojiData.Inner.WrappedImageData) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_CustomEmojiData.Inner.WrappedImageData.ImageData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Conversations_CustomEmojiData.Inner.WrappedImageData.protoMessageName + ".ImageData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}unknownInt1\0\u{1}mimeType\0\u{1}uri\0\u{2}\u{2}width\0\u{1}height\0\u{1}unknownInt7\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.unknownInt1) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.uri) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.width) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.height) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._unknownInt7) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.unknownInt1 != 0 {
      try visitor.visitSingularInt32Field(value: self.unknownInt1, fieldNumber: 1)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 2)
    }
    if !self.uri.isEmpty {
      try visitor.visitSingularStringField(value: self.uri, fieldNumber: 3)
    }
    if self.width != 0 {
      try visitor.visitSingularInt32Field(value: self.width, fieldNumber: 5)
    }
    if self.height != 0 {
      try visitor.visitSingularInt32Field(value: self.height, fieldNumber: 6)
    }
    try { if let v = self._unknownInt7 {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_CustomEmojiData.Inner.WrappedImageData.ImageData, rhs: Conversations_CustomEmojiData.Inner.WrappedImageData.ImageData) -> Bool {
    if lhs.unknownInt1 != rhs.unknownInt1 {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.uri != rhs.uri {return false}
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs._unknownInt7 != rhs._unknownInt7 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_ReactionData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReactionData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}unicode\0\u{1}type\0\u{2}c\u{1}customEmoji\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.unicode) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 101: try { try decoder.decodeSingularMessageField(value: &self._customEmoji) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.unicode.isEmpty {
      try visitor.visitSingularStringField(value: self.unicode, fieldNumber: 1)
    }
    if self.type != .reactionTypeUnspecified {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try { if let v = self._customEmoji {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_ReactionData, rhs: Conversations_ReactionData) -> Bool {
    if lhs.unicode != rhs.unicode {return false}
    if lhs.type != rhs.type {return false}
    if lhs._customEmoji != rhs._customEmoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_EmojiMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmojiMeta"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}emojiMetaData\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.emojiMetaData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emojiMetaData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.emojiMetaData, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_EmojiMeta, rhs: Conversations_EmojiMeta) -> Bool {
    if lhs.emojiMetaData != rhs.emojiMetaData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_EmojiMetaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EmojiMetaData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}unicode\0\u{1}names\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.unicode) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.names) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.unicode.isEmpty {
      try visitor.visitSingularStringField(value: self.unicode, fieldNumber: 1)
    }
    if !self.names.isEmpty {
      try visitor.visitRepeatedStringField(value: self.names, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_EmojiMetaData, rhs: Conversations_EmojiMetaData) -> Bool {
    if lhs.unicode != rhs.unicode {return false}
    if lhs.names != rhs.names {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_ReplyMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplyMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}messageID\0\u{1}conversationID\0\u{1}replyMessageData\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.conversationID) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._replyMessageData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.messageID.isEmpty {
      try visitor.visitSingularStringField(value: self.messageID, fieldNumber: 1)
    }
    if !self.conversationID.isEmpty {
      try visitor.visitSingularStringField(value: self.conversationID, fieldNumber: 2)
    }
    try { if let v = self._replyMessageData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_ReplyMessage, rhs: Conversations_ReplyMessage) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.conversationID != rhs.conversationID {return false}
    if lhs._replyMessageData != rhs._replyMessageData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_ReplyMessageData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ReplyMessageData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_ReplyMessageData, rhs: Conversations_ReplyMessageData) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_MessageInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}actionMessageID\0\u{1}messageContent\0\u{1}mediaContent\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._actionMessageID) }()
      case 2: try {
        var v: Conversations_MessageContent?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .messageContent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .messageContent(v)
        }
      }()
      case 3: try {
        var v: Conversations_MediaContent?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .mediaContent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .mediaContent(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._actionMessageID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    switch self.data {
    case .messageContent?: try {
      guard case .messageContent(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .mediaContent?: try {
      guard case .mediaContent(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_MessageInfo, rhs: Conversations_MessageInfo) -> Bool {
    if lhs._actionMessageID != rhs._actionMessageID {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_MediaContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MediaContent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}format\0\u{1}mediaID\0\u{2}\u{2}mediaName\0\u{1}size\0\u{1}dimensions\0\u{1}mediaData\0\u{2}\u{2}thumbnailMediaID\0\u{2}\u{2}decryptionKey\0\u{1}thumbnailDecryptionKey\0\u{2}\u{2}mimeType\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.mediaID) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.mediaName) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.size) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._dimensions) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.mediaData) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.thumbnailMediaID) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.decryptionKey) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self.thumbnailDecryptionKey) }()
      case 14: try { try decoder.decodeSingularStringField(value: &self.mimeType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.format != .unspecifiedType {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 1)
    }
    if !self.mediaID.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaID, fieldNumber: 2)
    }
    if !self.mediaName.isEmpty {
      try visitor.visitSingularStringField(value: self.mediaName, fieldNumber: 4)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 5)
    }
    try { if let v = self._dimensions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.mediaData.isEmpty {
      try visitor.visitSingularBytesField(value: self.mediaData, fieldNumber: 7)
    }
    if !self.thumbnailMediaID.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailMediaID, fieldNumber: 9)
    }
    if !self.decryptionKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.decryptionKey, fieldNumber: 11)
    }
    if !self.thumbnailDecryptionKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.thumbnailDecryptionKey, fieldNumber: 12)
    }
    if !self.mimeType.isEmpty {
      try visitor.visitSingularStringField(value: self.mimeType, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_MediaContent, rhs: Conversations_MediaContent) -> Bool {
    if lhs.format != rhs.format {return false}
    if lhs.mediaID != rhs.mediaID {return false}
    if lhs.mediaName != rhs.mediaName {return false}
    if lhs.size != rhs.size {return false}
    if lhs._dimensions != rhs._dimensions {return false}
    if lhs.mediaData != rhs.mediaData {return false}
    if lhs.thumbnailMediaID != rhs.thumbnailMediaID {return false}
    if lhs.decryptionKey != rhs.decryptionKey {return false}
    if lhs.thumbnailDecryptionKey != rhs.thumbnailDecryptionKey {return false}
    if lhs.mimeType != rhs.mimeType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_Dimensions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Dimensions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}width\0\u{1}height\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.width) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.height) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.width != 0 {
      try visitor.visitSingularInt64Field(value: self.width, fieldNumber: 1)
    }
    if self.height != 0 {
      try visitor.visitSingularInt64Field(value: self.height, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_Dimensions, rhs: Conversations_Dimensions) -> Bool {
    if lhs.width != rhs.width {return false}
    if lhs.height != rhs.height {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_MessageContent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageContent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}content\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.content) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.content.isEmpty {
      try visitor.visitSingularStringField(value: self.content, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_MessageContent, rhs: Conversations_MessageContent) -> Bool {
    if lhs.content != rhs.content {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_MsgType: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MsgType"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.type) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularInt64Field(value: self.type, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_MsgType, rhs: Conversations_MsgType) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_MessageStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}status\0\u{1}subCode\0\u{1}errMsg\0\u{1}statusText\0\u{1}thirdCode\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.subCode) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.errMsg) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.statusText) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.thirdCode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status != .statusUnknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if self.subCode != 0 {
      try visitor.visitSingularInt64Field(value: self.subCode, fieldNumber: 3)
    }
    if !self.errMsg.isEmpty {
      try visitor.visitSingularStringField(value: self.errMsg, fieldNumber: 4)
    }
    if !self.statusText.isEmpty {
      try visitor.visitSingularStringField(value: self.statusText, fieldNumber: 5)
    }
    if self.thirdCode != 0 {
      try visitor.visitSingularInt64Field(value: self.thirdCode, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_MessageStatus, rhs: Conversations_MessageStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.subCode != rhs.subCode {return false}
    if lhs.errMsg != rhs.errMsg {return false}
    if lhs.statusText != rhs.statusText {return false}
    if lhs.thirdCode != rhs.thirdCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_Conversation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Conversation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conversationID\0\u{1}name\0\u{2}\u{2}latestMessage\0\u{1}lastMessageTimestamp\0\u{1}unread\0\u{2}\u{4}isGroupChat\0\u{1}defaultOutgoingID\0\u{1}status\0\u{1}readOnly\0\u{2}\u{2}avatarHexColor\0\u{2}\u{2}latestMessageID\0\u{1}sendMode\0\u{2}\u{2}participants\0\u{1}otherParticipants\0\u{1}type\0\u{2}\u{2}subType\0\u{2}\u{2}pinned\0\u{2}\u{2}unknownTimestamp\0\u{1}thirdType\0\u{2}\u{2}someKindOfGroupID\0\u{1}simCard\0\u{2}\u{3}latestMessageAnoherID\0")

  fileprivate class _StorageClass {
    var _conversationID: String = String()
    var _name: String = String()
    var _latestMessage: Conversations_LatestMessage? = nil
    var _lastMessageTimestamp: Int64 = 0
    var _unread: Bool = false
    var _isGroupChat: Bool = false
    var _defaultOutgoingID: String = String()
    var _status: Conversations_ConversationStatus = .unknownConversationStatus
    var _readOnly: Bool = false
    var _avatarHexColor: String = String()
    var _latestMessageID: String = String()
    var _sendMode: Conversations_ConversationSendMode = .sendModeAuto
    var _participants: [Conversations_Participant] = []
    var _otherParticipants: [String] = []
    var _type: Conversations_ConversationType = .unknownConversationType
    var _subType: Bool = false
    var _pinned: Bool = false
    var _unknownTimestamp: Int64 = 0
    var _thirdType: Bool = false
    var _someKindOfGroupID: Conversations_SomeKindOfGroupID? = nil
    var _simCard: Settings_SIMCard? = nil
    var _latestMessageAnoherID: Conversations_AnotherMessageID? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _conversationID = source._conversationID
      _name = source._name
      _latestMessage = source._latestMessage
      _lastMessageTimestamp = source._lastMessageTimestamp
      _unread = source._unread
      _isGroupChat = source._isGroupChat
      _defaultOutgoingID = source._defaultOutgoingID
      _status = source._status
      _readOnly = source._readOnly
      _avatarHexColor = source._avatarHexColor
      _latestMessageID = source._latestMessageID
      _sendMode = source._sendMode
      _participants = source._participants
      _otherParticipants = source._otherParticipants
      _type = source._type
      _subType = source._subType
      _pinned = source._pinned
      _unknownTimestamp = source._unknownTimestamp
      _thirdType = source._thirdType
      _someKindOfGroupID = source._someKindOfGroupID
      _simCard = source._simCard
      _latestMessageAnoherID = source._latestMessageAnoherID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._conversationID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._latestMessage) }()
        case 5: try { try decoder.decodeSingularInt64Field(value: &_storage._lastMessageTimestamp) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._unread) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._isGroupChat) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._defaultOutgoingID) }()
        case 12: try { try decoder.decodeSingularEnumField(value: &_storage._status) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._readOnly) }()
        case 15: try { try decoder.decodeSingularStringField(value: &_storage._avatarHexColor) }()
        case 17: try { try decoder.decodeSingularStringField(value: &_storage._latestMessageID) }()
        case 18: try { try decoder.decodeSingularEnumField(value: &_storage._sendMode) }()
        case 20: try { try decoder.decodeRepeatedMessageField(value: &_storage._participants) }()
        case 21: try { try decoder.decodeRepeatedStringField(value: &_storage._otherParticipants) }()
        case 22: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 24: try { try decoder.decodeSingularBoolField(value: &_storage._subType) }()
        case 26: try { try decoder.decodeSingularBoolField(value: &_storage._pinned) }()
        case 28: try { try decoder.decodeSingularInt64Field(value: &_storage._unknownTimestamp) }()
        case 29: try { try decoder.decodeSingularBoolField(value: &_storage._thirdType) }()
        case 31: try { try decoder.decodeSingularMessageField(value: &_storage._someKindOfGroupID) }()
        case 32: try { try decoder.decodeSingularMessageField(value: &_storage._simCard) }()
        case 35: try { try decoder.decodeSingularMessageField(value: &_storage._latestMessageAnoherID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._conversationID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._conversationID, fieldNumber: 1)
      }
      if !_storage._name.isEmpty {
        try visitor.visitSingularStringField(value: _storage._name, fieldNumber: 2)
      }
      try { if let v = _storage._latestMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._lastMessageTimestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastMessageTimestamp, fieldNumber: 5)
      }
      if _storage._unread != false {
        try visitor.visitSingularBoolField(value: _storage._unread, fieldNumber: 6)
      }
      if _storage._isGroupChat != false {
        try visitor.visitSingularBoolField(value: _storage._isGroupChat, fieldNumber: 10)
      }
      if !_storage._defaultOutgoingID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._defaultOutgoingID, fieldNumber: 11)
      }
      if _storage._status != .unknownConversationStatus {
        try visitor.visitSingularEnumField(value: _storage._status, fieldNumber: 12)
      }
      if _storage._readOnly != false {
        try visitor.visitSingularBoolField(value: _storage._readOnly, fieldNumber: 13)
      }
      if !_storage._avatarHexColor.isEmpty {
        try visitor.visitSingularStringField(value: _storage._avatarHexColor, fieldNumber: 15)
      }
      if !_storage._latestMessageID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._latestMessageID, fieldNumber: 17)
      }
      if _storage._sendMode != .sendModeAuto {
        try visitor.visitSingularEnumField(value: _storage._sendMode, fieldNumber: 18)
      }
      if !_storage._participants.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._participants, fieldNumber: 20)
      }
      if !_storage._otherParticipants.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._otherParticipants, fieldNumber: 21)
      }
      if _storage._type != .unknownConversationType {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 22)
      }
      if _storage._subType != false {
        try visitor.visitSingularBoolField(value: _storage._subType, fieldNumber: 24)
      }
      if _storage._pinned != false {
        try visitor.visitSingularBoolField(value: _storage._pinned, fieldNumber: 26)
      }
      if _storage._unknownTimestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unknownTimestamp, fieldNumber: 28)
      }
      if _storage._thirdType != false {
        try visitor.visitSingularBoolField(value: _storage._thirdType, fieldNumber: 29)
      }
      try { if let v = _storage._someKindOfGroupID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      } }()
      try { if let v = _storage._simCard {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      } }()
      try { if let v = _storage._latestMessageAnoherID {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 35)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_Conversation, rhs: Conversations_Conversation) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._conversationID != rhs_storage._conversationID {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._latestMessage != rhs_storage._latestMessage {return false}
        if _storage._lastMessageTimestamp != rhs_storage._lastMessageTimestamp {return false}
        if _storage._unread != rhs_storage._unread {return false}
        if _storage._isGroupChat != rhs_storage._isGroupChat {return false}
        if _storage._defaultOutgoingID != rhs_storage._defaultOutgoingID {return false}
        if _storage._status != rhs_storage._status {return false}
        if _storage._readOnly != rhs_storage._readOnly {return false}
        if _storage._avatarHexColor != rhs_storage._avatarHexColor {return false}
        if _storage._latestMessageID != rhs_storage._latestMessageID {return false}
        if _storage._sendMode != rhs_storage._sendMode {return false}
        if _storage._participants != rhs_storage._participants {return false}
        if _storage._otherParticipants != rhs_storage._otherParticipants {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._subType != rhs_storage._subType {return false}
        if _storage._pinned != rhs_storage._pinned {return false}
        if _storage._unknownTimestamp != rhs_storage._unknownTimestamp {return false}
        if _storage._thirdType != rhs_storage._thirdType {return false}
        if _storage._someKindOfGroupID != rhs_storage._someKindOfGroupID {return false}
        if _storage._simCard != rhs_storage._simCard {return false}
        if _storage._latestMessageAnoherID != rhs_storage._latestMessageAnoherID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_Participant: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Participant"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}ID\0\u{1}firstName\0\u{1}fullName\0\u{2}\u{2}avatarHexColor\0\u{1}isMe\0\u{1}simPayload\0\u{1}isVisible\0\u{2}\u{2}contactID\0\u{2}\u{4}bs\0\u{1}formattedNumber\0\u{2}\u{4}someInt1\0\u{1}someInt2\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.firstName) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.fullName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.avatarHexColor) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.isMe) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._simPayload) }()
      case 8: try { try decoder.decodeSingularBoolField(value: &self.isVisible) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.contactID) }()
      case 14: try { try decoder.decodeSingularInt64Field(value: &self.bs) }()
      case 15: try { try decoder.decodeSingularStringField(value: &self.formattedNumber) }()
      case 19: try { try decoder.decodeSingularInt64Field(value: &self.someInt1) }()
      case 20: try { try decoder.decodeSingularInt64Field(value: &self.someInt2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.firstName.isEmpty {
      try visitor.visitSingularStringField(value: self.firstName, fieldNumber: 2)
    }
    if !self.fullName.isEmpty {
      try visitor.visitSingularStringField(value: self.fullName, fieldNumber: 3)
    }
    if !self.avatarHexColor.isEmpty {
      try visitor.visitSingularStringField(value: self.avatarHexColor, fieldNumber: 5)
    }
    if self.isMe != false {
      try visitor.visitSingularBoolField(value: self.isMe, fieldNumber: 6)
    }
    try { if let v = self._simPayload {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    if self.isVisible != false {
      try visitor.visitSingularBoolField(value: self.isVisible, fieldNumber: 8)
    }
    if !self.contactID.isEmpty {
      try visitor.visitSingularStringField(value: self.contactID, fieldNumber: 10)
    }
    if self.bs != 0 {
      try visitor.visitSingularInt64Field(value: self.bs, fieldNumber: 14)
    }
    if !self.formattedNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.formattedNumber, fieldNumber: 15)
    }
    if self.someInt1 != 0 {
      try visitor.visitSingularInt64Field(value: self.someInt1, fieldNumber: 19)
    }
    if self.someInt2 != 0 {
      try visitor.visitSingularInt64Field(value: self.someInt2, fieldNumber: 20)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_Participant, rhs: Conversations_Participant) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.firstName != rhs.firstName {return false}
    if lhs.fullName != rhs.fullName {return false}
    if lhs.avatarHexColor != rhs.avatarHexColor {return false}
    if lhs.isMe != rhs.isMe {return false}
    if lhs._simPayload != rhs._simPayload {return false}
    if lhs.isVisible != rhs.isVisible {return false}
    if lhs.contactID != rhs.contactID {return false}
    if lhs.bs != rhs.bs {return false}
    if lhs.formattedNumber != rhs.formattedNumber {return false}
    if lhs.someInt1 != rhs.someInt1 {return false}
    if lhs.someInt2 != rhs.someInt2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_SmallInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SmallInfo"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}number\0\u{1}participantID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.number) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.participantID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknown {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.number.isEmpty {
      try visitor.visitSingularStringField(value: self.number, fieldNumber: 2)
    }
    if !self.participantID.isEmpty {
      try visitor.visitSingularStringField(value: self.participantID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_SmallInfo, rhs: Conversations_SmallInfo) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.number != rhs.number {return false}
    if lhs.participantID != rhs.participantID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_LatestMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LatestMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}displayContent\0\u{1}fromMe\0\u{2}\u{2}displayName\0\u{1}latestMessageStatus\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.displayContent) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.fromMe) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.displayName) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._latestMessageStatus) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.displayContent.isEmpty {
      try visitor.visitSingularStringField(value: self.displayContent, fieldNumber: 1)
    }
    if self.fromMe != 0 {
      try visitor.visitSingularInt64Field(value: self.fromMe, fieldNumber: 2)
    }
    if !self.displayName.isEmpty {
      try visitor.visitSingularStringField(value: self.displayName, fieldNumber: 4)
    }
    try { if let v = self._latestMessageStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_LatestMessage, rhs: Conversations_LatestMessage) -> Bool {
    if lhs.displayContent != rhs.displayContent {return false}
    if lhs.fromMe != rhs.fromMe {return false}
    if lhs.displayName != rhs.displayName {return false}
    if lhs._latestMessageStatus != rhs._latestMessageStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_LatestMessageStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LatestMessageStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}status2\0\u{1}status\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.status2) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.status2 != 0 {
      try visitor.visitSingularInt64Field(value: self.status2, fieldNumber: 1)
    }
    if self.status != .statusUnknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_LatestMessageStatus, rhs: Conversations_LatestMessageStatus) -> Bool {
    if lhs.status2 != rhs.status2 {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Conversations_Muted: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Muted"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}isMuted\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.isMuted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isMuted != 0 {
      try visitor.visitSingularInt64Field(value: self.isMuted, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Conversations_Muted, rhs: Conversations_Muted) -> Bool {
    if lhs.isMuted != rhs.isMuted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
