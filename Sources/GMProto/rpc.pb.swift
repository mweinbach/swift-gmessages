// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: rpc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Rpc_BugleRoute: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case dataEvent // = 19
  case pairEvent // = 14
  case gaiaEvent // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 7: self = .gaiaEvent
    case 14: self = .pairEvent
    case 19: self = .dataEvent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .gaiaEvent: return 7
    case .pairEvent: return 14
    case .dataEvent: return 19
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rpc_BugleRoute] = [
    .unknown,
    .dataEvent,
    .pairEvent,
    .gaiaEvent,
  ]

}

public enum Rpc_ActionType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unspecified // = 0
  case listConversations // = 1
  case listMessages // = 2
  case sendMessage // = 3
  case messageUpdates // = 4
  case listContacts // = 6
  case conversationUpdates // = 7
  case getOrCreateConversation // = 9
  case messageRead // = 10
  case browserPresenceCheck // = 11
  case typingUpdates // = 12
  case settingsUpdate // = 13
  case userAlert // = 14
  case updateConversation // = 15
  case getUpdates // = 16
  case ackBrowserPresence // = 17
  case listStickerSets // = 18
  case leaveRcsGroup // = 19
  case addParticipantToRcsGroup // = 20
  case getConversationType // = 21
  case notifyDittoActivity // = 22
  case deleteMessage // = 23
  case installStickerSet // = 24
  case resendMessage // = 25
  case getContactRcsGroupStatus // = 26
  case downloadMessage // = 27
  case listTopContacts // = 28
  case getContactsThumbnail // = 29
  case changeParticipantColor // = 30
  case isBugleDefault // = 31
  case stickerUserContext // = 32
  case favoriteStickerPacks // = 33
  case recentStickers // = 34
  case updateRecentStickers // = 35
  case getFullSizeImage // = 36
  case getParticipantsThumbnail // = 37
  case sendReaction // = 38
  case sendReply // = 39
  case getBlobForAttachment // = 40
  case getDevicesAvailableForGaiaPairing // = 41
  case createGaiaPairing // = 42
  case getConversation // = 43
  case createGaiaPairingClientInit // = 44
  case createGaiaPairingClientFinished // = 45
  case unpairGaiaPairing // = 46
  case cancelGaiaPairing // = 47
  case prewarm // = 48
  case conversationGroupNameSearch // = 49
  case linkRcsIdentity // = 50
  case unlinkRcsIdentity // = 51
  case UNRECOGNIZED(Int)

  public init() {
    self = .unspecified
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .listConversations
    case 2: self = .listMessages
    case 3: self = .sendMessage
    case 4: self = .messageUpdates
    case 6: self = .listContacts
    case 7: self = .conversationUpdates
    case 9: self = .getOrCreateConversation
    case 10: self = .messageRead
    case 11: self = .browserPresenceCheck
    case 12: self = .typingUpdates
    case 13: self = .settingsUpdate
    case 14: self = .userAlert
    case 15: self = .updateConversation
    case 16: self = .getUpdates
    case 17: self = .ackBrowserPresence
    case 18: self = .listStickerSets
    case 19: self = .leaveRcsGroup
    case 20: self = .addParticipantToRcsGroup
    case 21: self = .getConversationType
    case 22: self = .notifyDittoActivity
    case 23: self = .deleteMessage
    case 24: self = .installStickerSet
    case 25: self = .resendMessage
    case 26: self = .getContactRcsGroupStatus
    case 27: self = .downloadMessage
    case 28: self = .listTopContacts
    case 29: self = .getContactsThumbnail
    case 30: self = .changeParticipantColor
    case 31: self = .isBugleDefault
    case 32: self = .stickerUserContext
    case 33: self = .favoriteStickerPacks
    case 34: self = .recentStickers
    case 35: self = .updateRecentStickers
    case 36: self = .getFullSizeImage
    case 37: self = .getParticipantsThumbnail
    case 38: self = .sendReaction
    case 39: self = .sendReply
    case 40: self = .getBlobForAttachment
    case 41: self = .getDevicesAvailableForGaiaPairing
    case 42: self = .createGaiaPairing
    case 43: self = .getConversation
    case 44: self = .createGaiaPairingClientInit
    case 45: self = .createGaiaPairingClientFinished
    case 46: self = .unpairGaiaPairing
    case 47: self = .cancelGaiaPairing
    case 48: self = .prewarm
    case 49: self = .conversationGroupNameSearch
    case 50: self = .linkRcsIdentity
    case 51: self = .unlinkRcsIdentity
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .listConversations: return 1
    case .listMessages: return 2
    case .sendMessage: return 3
    case .messageUpdates: return 4
    case .listContacts: return 6
    case .conversationUpdates: return 7
    case .getOrCreateConversation: return 9
    case .messageRead: return 10
    case .browserPresenceCheck: return 11
    case .typingUpdates: return 12
    case .settingsUpdate: return 13
    case .userAlert: return 14
    case .updateConversation: return 15
    case .getUpdates: return 16
    case .ackBrowserPresence: return 17
    case .listStickerSets: return 18
    case .leaveRcsGroup: return 19
    case .addParticipantToRcsGroup: return 20
    case .getConversationType: return 21
    case .notifyDittoActivity: return 22
    case .deleteMessage: return 23
    case .installStickerSet: return 24
    case .resendMessage: return 25
    case .getContactRcsGroupStatus: return 26
    case .downloadMessage: return 27
    case .listTopContacts: return 28
    case .getContactsThumbnail: return 29
    case .changeParticipantColor: return 30
    case .isBugleDefault: return 31
    case .stickerUserContext: return 32
    case .favoriteStickerPacks: return 33
    case .recentStickers: return 34
    case .updateRecentStickers: return 35
    case .getFullSizeImage: return 36
    case .getParticipantsThumbnail: return 37
    case .sendReaction: return 38
    case .sendReply: return 39
    case .getBlobForAttachment: return 40
    case .getDevicesAvailableForGaiaPairing: return 41
    case .createGaiaPairing: return 42
    case .getConversation: return 43
    case .createGaiaPairingClientInit: return 44
    case .createGaiaPairingClientFinished: return 45
    case .unpairGaiaPairing: return 46
    case .cancelGaiaPairing: return 47
    case .prewarm: return 48
    case .conversationGroupNameSearch: return 49
    case .linkRcsIdentity: return 50
    case .unlinkRcsIdentity: return 51
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rpc_ActionType] = [
    .unspecified,
    .listConversations,
    .listMessages,
    .sendMessage,
    .messageUpdates,
    .listContacts,
    .conversationUpdates,
    .getOrCreateConversation,
    .messageRead,
    .browserPresenceCheck,
    .typingUpdates,
    .settingsUpdate,
    .userAlert,
    .updateConversation,
    .getUpdates,
    .ackBrowserPresence,
    .listStickerSets,
    .leaveRcsGroup,
    .addParticipantToRcsGroup,
    .getConversationType,
    .notifyDittoActivity,
    .deleteMessage,
    .installStickerSet,
    .resendMessage,
    .getContactRcsGroupStatus,
    .downloadMessage,
    .listTopContacts,
    .getContactsThumbnail,
    .changeParticipantColor,
    .isBugleDefault,
    .stickerUserContext,
    .favoriteStickerPacks,
    .recentStickers,
    .updateRecentStickers,
    .getFullSizeImage,
    .getParticipantsThumbnail,
    .sendReaction,
    .sendReply,
    .getBlobForAttachment,
    .getDevicesAvailableForGaiaPairing,
    .createGaiaPairing,
    .getConversation,
    .createGaiaPairingClientInit,
    .createGaiaPairingClientFinished,
    .unpairGaiaPairing,
    .cancelGaiaPairing,
    .prewarm,
    .conversationGroupNameSearch,
    .linkRcsIdentity,
    .unlinkRcsIdentity,
  ]

}

public enum Rpc_MessageType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknownMessageType // = 0
  case bugleMessage // = 2
  case gaia1 // = 3
  case bugleAnnotation // = 16
  case gaia2 // = 20
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownMessageType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownMessageType
    case 2: self = .bugleMessage
    case 3: self = .gaia1
    case 16: self = .bugleAnnotation
    case 20: self = .gaia2
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownMessageType: return 0
    case .bugleMessage: return 2
    case .gaia1: return 3
    case .bugleAnnotation: return 16
    case .gaia2: return 20
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Rpc_MessageType] = [
    .unknownMessageType,
    .bugleMessage,
    .gaia1,
    .bugleAnnotation,
    .gaia2,
  ]

}

public struct Rpc_StartAckMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var count: Int32 {
    get {return _count ?? 0}
    set {_count = newValue}
  }
  /// Returns true if `count` has been explicitly set.
  public var hasCount: Bool {return self._count != nil}
  /// Clears the value of `count`. Subsequent reads from it will return its default value.
  public mutating func clearCount() {self._count = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _count: Int32? = nil
}

public struct Rpc_LongPollingPayload: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var data: Rpc_IncomingRPCMessage {
    get {return _storage._data ?? Rpc_IncomingRPCMessage()}
    set {_uniqueStorage()._data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return _storage._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {_uniqueStorage()._data = nil}

  public var heartbeat: Util_EmptyArr {
    get {return _storage._heartbeat ?? Util_EmptyArr()}
    set {_uniqueStorage()._heartbeat = newValue}
  }
  /// Returns true if `heartbeat` has been explicitly set.
  public var hasHeartbeat: Bool {return _storage._heartbeat != nil}
  /// Clears the value of `heartbeat`. Subsequent reads from it will return its default value.
  public mutating func clearHeartbeat() {_uniqueStorage()._heartbeat = nil}

  public var ack: Rpc_StartAckMessage {
    get {return _storage._ack ?? Rpc_StartAckMessage()}
    set {_uniqueStorage()._ack = newValue}
  }
  /// Returns true if `ack` has been explicitly set.
  public var hasAck: Bool {return _storage._ack != nil}
  /// Clears the value of `ack`. Subsequent reads from it will return its default value.
  public mutating func clearAck() {_uniqueStorage()._ack = nil}

  public var startRead: Util_EmptyArr {
    get {return _storage._startRead ?? Util_EmptyArr()}
    set {_uniqueStorage()._startRead = newValue}
  }
  /// Returns true if `startRead` has been explicitly set.
  public var hasStartRead: Bool {return _storage._startRead != nil}
  /// Clears the value of `startRead`. Subsequent reads from it will return its default value.
  public mutating func clearStartRead() {_uniqueStorage()._startRead = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Rpc_IncomingRPCMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var responseID: String = String()

  public var bugleRoute: Rpc_BugleRoute = .unknown

  public var startExecute: UInt64 = 0

  public var messageType: Rpc_MessageType = .unknownMessageType

  public var finishExecute: UInt64 = 0

  public var microsecondsTaken: UInt64 = 0

  public var mobile: Authentication_Device {
    get {return _mobile ?? Authentication_Device()}
    set {_mobile = newValue}
  }
  /// Returns true if `mobile` has been explicitly set.
  public var hasMobile: Bool {return self._mobile != nil}
  /// Clears the value of `mobile`. Subsequent reads from it will return its default value.
  public mutating func clearMobile() {self._mobile = nil}

  public var browser: Authentication_Device {
    get {return _browser ?? Authentication_Device()}
    set {_browser = newValue}
  }
  /// Returns true if `browser` has been explicitly set.
  public var hasBrowser: Bool {return self._browser != nil}
  /// Clears the value of `browser`. Subsequent reads from it will return its default value.
  public mutating func clearBrowser() {self._browser = nil}

  /// Either a RPCMessageData or a RPCPairData encoded as bytes
  public var messageData: Data = Data()

  public var signatureID: String = String()

  public var timestamp: String = String()

  /// Completely unsure about this, but it seems to be present for weird intermediate responses
  public var gdittoSource: Rpc_IncomingRPCMessage.GDittoSource {
    get {return _gdittoSource ?? Rpc_IncomingRPCMessage.GDittoSource()}
    set {_gdittoSource = newValue}
  }
  /// Returns true if `gdittoSource` has been explicitly set.
  public var hasGdittoSource: Bool {return self._gdittoSource != nil}
  /// Clears the value of `gdittoSource`. Subsequent reads from it will return its default value.
  public mutating func clearGdittoSource() {self._gdittoSource = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct GDittoSource: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var deviceID: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _mobile: Authentication_Device? = nil
  fileprivate var _browser: Authentication_Device? = nil
  fileprivate var _gdittoSource: Rpc_IncomingRPCMessage.GDittoSource? = nil
}

public struct Rpc_RPCMessageData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var sessionID: String = String()

  public var timestamp: Int64 = 0

  public var action: Rpc_ActionType = .unspecified

  public var unencryptedData: Data = Data()

  public var bool1: Bool = false

  public var bool2: Bool = false

  public var encryptedData: Data = Data()

  public var bool3: Bool = false

  public var encryptedData2: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rpc_OutgoingRPCMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mobile: Authentication_Device {
    get {return _mobile ?? Authentication_Device()}
    set {_mobile = newValue}
  }
  /// Returns true if `mobile` has been explicitly set.
  public var hasMobile: Bool {return self._mobile != nil}
  /// Clears the value of `mobile`. Subsequent reads from it will return its default value.
  public mutating func clearMobile() {self._mobile = nil}

  public var data: Rpc_OutgoingRPCMessage.DataMessage {
    get {return _data ?? Rpc_OutgoingRPCMessage.DataMessage()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  public var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  public mutating func clearData() {self._data = nil}

  public var auth: Rpc_OutgoingRPCMessage.Auth {
    get {return _auth ?? Rpc_OutgoingRPCMessage.Auth()}
    set {_auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  public var hasAuth: Bool {return self._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  public mutating func clearAuth() {self._auth = nil}

  public var ttl: Int64 = 0

  public var destRegistrationIds: [String] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Auth: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var requestID: String = String()

    public var tachyonAuthToken: Data = Data()

    public var configVersion: Authentication_ConfigVersion {
      get {return _configVersion ?? Authentication_ConfigVersion()}
      set {_configVersion = newValue}
    }
    /// Returns true if `configVersion` has been explicitly set.
    public var hasConfigVersion: Bool {return self._configVersion != nil}
    /// Clears the value of `configVersion`. Subsequent reads from it will return its default value.
    public mutating func clearConfigVersion() {self._configVersion = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _configVersion: Authentication_ConfigVersion? = nil
  }

  public struct DataMessage: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var requestID: String = String()

    public var bugleRoute: Rpc_BugleRoute = .unknown

    /// OutgoingRPCData encoded as bytes
    public var messageData: Data = Data()

    public var messageTypeData: Rpc_OutgoingRPCMessage.DataMessage.TypeMessage {
      get {return _messageTypeData ?? Rpc_OutgoingRPCMessage.DataMessage.TypeMessage()}
      set {_messageTypeData = newValue}
    }
    /// Returns true if `messageTypeData` has been explicitly set.
    public var hasMessageTypeData: Bool {return self._messageTypeData != nil}
    /// Clears the value of `messageTypeData`. Subsequent reads from it will return its default value.
    public mutating func clearMessageTypeData() {self._messageTypeData = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct TypeMessage: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var emptyArr: Util_EmptyArr {
        get {return _emptyArr ?? Util_EmptyArr()}
        set {_emptyArr = newValue}
      }
      /// Returns true if `emptyArr` has been explicitly set.
      public var hasEmptyArr: Bool {return self._emptyArr != nil}
      /// Clears the value of `emptyArr`. Subsequent reads from it will return its default value.
      public mutating func clearEmptyArr() {self._emptyArr = nil}

      public var messageType: Rpc_MessageType = .unknownMessageType

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _emptyArr: Util_EmptyArr? = nil
    }

    public init() {}

    fileprivate var _messageTypeData: Rpc_OutgoingRPCMessage.DataMessage.TypeMessage? = nil
  }

  public init() {}

  fileprivate var _mobile: Authentication_Device? = nil
  fileprivate var _data: Rpc_OutgoingRPCMessage.DataMessage? = nil
  fileprivate var _auth: Rpc_OutgoingRPCMessage.Auth? = nil
}

public struct Rpc_OutgoingRPCData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: String = String()

  public var action: Rpc_ActionType = .unspecified

  public var unencryptedProtoData: Data = Data()

  public var encryptedProtoData: Data = Data()

  public var sessionID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Rpc_OutgoingRPCResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var someIdentifier: Rpc_OutgoingRPCResponse.SomeIdentifier {
    get {return _someIdentifier ?? Rpc_OutgoingRPCResponse.SomeIdentifier()}
    set {_someIdentifier = newValue}
  }
  /// Returns true if `someIdentifier` has been explicitly set.
  public var hasSomeIdentifier: Bool {return self._someIdentifier != nil}
  /// Clears the value of `someIdentifier`. Subsequent reads from it will return its default value.
  public mutating func clearSomeIdentifier() {self._someIdentifier = nil}

  /// This is not present for AckMessage responses, only for SendMessage
  public var timestamp: String {
    get {return _timestamp ?? String()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  public var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  public mutating func clearTimestamp() {self._timestamp = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct SomeIdentifier: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 1 -> unknown
    public var someNumber: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _someIdentifier: Rpc_OutgoingRPCResponse.SomeIdentifier? = nil
  fileprivate var _timestamp: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "rpc"

extension Rpc_BugleRoute: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Unknown\0\u{2}\u{7}GaiaEvent\0\u{2}\u{7}PairEvent\0\u{2}\u{5}DataEvent\0")
}

extension Rpc_ActionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNSPECIFIED\0\u{1}LIST_CONVERSATIONS\0\u{1}LIST_MESSAGES\0\u{1}SEND_MESSAGE\0\u{1}MESSAGE_UPDATES\0\u{2}\u{2}LIST_CONTACTS\0\u{1}CONVERSATION_UPDATES\0\u{2}\u{2}GET_OR_CREATE_CONVERSATION\0\u{1}MESSAGE_READ\0\u{1}BROWSER_PRESENCE_CHECK\0\u{1}TYPING_UPDATES\0\u{1}SETTINGS_UPDATE\0\u{1}USER_ALERT\0\u{1}UPDATE_CONVERSATION\0\u{1}GET_UPDATES\0\u{1}ACK_BROWSER_PRESENCE\0\u{1}LIST_STICKER_SETS\0\u{1}LEAVE_RCS_GROUP\0\u{1}ADD_PARTICIPANT_TO_RCS_GROUP\0\u{1}GET_CONVERSATION_TYPE\0\u{1}NOTIFY_DITTO_ACTIVITY\0\u{1}DELETE_MESSAGE\0\u{1}INSTALL_STICKER_SET\0\u{1}RESEND_MESSAGE\0\u{1}GET_CONTACT_RCS_GROUP_STATUS\0\u{1}DOWNLOAD_MESSAGE\0\u{1}LIST_TOP_CONTACTS\0\u{1}GET_CONTACTS_THUMBNAIL\0\u{1}CHANGE_PARTICIPANT_COLOR\0\u{1}IS_BUGLE_DEFAULT\0\u{1}STICKER_USER_CONTEXT\0\u{1}FAVORITE_STICKER_PACKS\0\u{1}RECENT_STICKERS\0\u{1}UPDATE_RECENT_STICKERS\0\u{1}GET_FULL_SIZE_IMAGE\0\u{1}GET_PARTICIPANTS_THUMBNAIL\0\u{1}SEND_REACTION\0\u{1}SEND_REPLY\0\u{1}GET_BLOB_FOR_ATTACHMENT\0\u{1}GET_DEVICES_AVAILABLE_FOR_GAIA_PAIRING\0\u{1}CREATE_GAIA_PAIRING\0\u{1}GET_CONVERSATION\0\u{1}CREATE_GAIA_PAIRING_CLIENT_INIT\0\u{1}CREATE_GAIA_PAIRING_CLIENT_FINISHED\0\u{1}UNPAIR_GAIA_PAIRING\0\u{1}CANCEL_GAIA_PAIRING\0\u{1}PREWARM\0\u{1}CONVERSATION_GROUP_NAME_SEARCH\0\u{1}LINK_RCS_IDENTITY\0\u{1}UNLINK_RCS_IDENTITY\0")
}

extension Rpc_MessageType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN_MESSAGE_TYPE\0\u{2}\u{2}BUGLE_MESSAGE\0\u{1}GAIA_1\0\u{2}\u{d}BUGLE_ANNOTATION\0\u{2}\u{4}GAIA_2\0")
}

extension Rpc_StartAckMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".StartAckMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}count\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self._count) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._count {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_StartAckMessage, rhs: Rpc_StartAckMessage) -> Bool {
    if lhs._count != rhs._count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_LongPollingPayload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".LongPollingPayload"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}data\0\u{1}heartbeat\0\u{1}ack\0\u{1}startRead\0")

  fileprivate class _StorageClass {
    var _data: Rpc_IncomingRPCMessage? = nil
    var _heartbeat: Util_EmptyArr? = nil
    var _ack: Rpc_StartAckMessage? = nil
    var _startRead: Util_EmptyArr? = nil

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _data = source._data
      _heartbeat = source._heartbeat
      _ack = source._ack
      _startRead = source._startRead
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._data) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._heartbeat) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._ack) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._startRead) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._data {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._heartbeat {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._ack {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._startRead {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_LongPollingPayload, rhs: Rpc_LongPollingPayload) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._data != rhs_storage._data {return false}
        if _storage._heartbeat != rhs_storage._heartbeat {return false}
        if _storage._ack != rhs_storage._ack {return false}
        if _storage._startRead != rhs_storage._startRead {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_IncomingRPCMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".IncomingRPCMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}responseID\0\u{1}bugleRoute\0\u{1}startExecute\0\u{2}\u{2}messageType\0\u{1}finishExecute\0\u{1}microsecondsTaken\0\u{1}mobile\0\u{1}browser\0\u{2}\u{3}messageData\0\u{2}\u{5}signatureID\0\u{2}\u{4}timestamp\0\u{2}\u{2}gdittoSource\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.responseID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.bugleRoute) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.startExecute) }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self.messageType) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.finishExecute) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.microsecondsTaken) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._mobile) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._browser) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self.messageData) }()
      case 17: try { try decoder.decodeSingularStringField(value: &self.signatureID) }()
      case 21: try { try decoder.decodeSingularStringField(value: &self.timestamp) }()
      case 23: try { try decoder.decodeSingularMessageField(value: &self._gdittoSource) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.responseID.isEmpty {
      try visitor.visitSingularStringField(value: self.responseID, fieldNumber: 1)
    }
    if self.bugleRoute != .unknown {
      try visitor.visitSingularEnumField(value: self.bugleRoute, fieldNumber: 2)
    }
    if self.startExecute != 0 {
      try visitor.visitSingularUInt64Field(value: self.startExecute, fieldNumber: 3)
    }
    if self.messageType != .unknownMessageType {
      try visitor.visitSingularEnumField(value: self.messageType, fieldNumber: 5)
    }
    if self.finishExecute != 0 {
      try visitor.visitSingularUInt64Field(value: self.finishExecute, fieldNumber: 6)
    }
    if self.microsecondsTaken != 0 {
      try visitor.visitSingularUInt64Field(value: self.microsecondsTaken, fieldNumber: 7)
    }
    try { if let v = self._mobile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._browser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    if !self.messageData.isEmpty {
      try visitor.visitSingularBytesField(value: self.messageData, fieldNumber: 12)
    }
    if !self.signatureID.isEmpty {
      try visitor.visitSingularStringField(value: self.signatureID, fieldNumber: 17)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitSingularStringField(value: self.timestamp, fieldNumber: 21)
    }
    try { if let v = self._gdittoSource {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_IncomingRPCMessage, rhs: Rpc_IncomingRPCMessage) -> Bool {
    if lhs.responseID != rhs.responseID {return false}
    if lhs.bugleRoute != rhs.bugleRoute {return false}
    if lhs.startExecute != rhs.startExecute {return false}
    if lhs.messageType != rhs.messageType {return false}
    if lhs.finishExecute != rhs.finishExecute {return false}
    if lhs.microsecondsTaken != rhs.microsecondsTaken {return false}
    if lhs._mobile != rhs._mobile {return false}
    if lhs._browser != rhs._browser {return false}
    if lhs.messageData != rhs.messageData {return false}
    if lhs.signatureID != rhs.signatureID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._gdittoSource != rhs._gdittoSource {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_IncomingRPCMessage.GDittoSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rpc_IncomingRPCMessage.protoMessageName + ".GDittoSource"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}deviceID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.deviceID != 0 {
      try visitor.visitSingularInt32Field(value: self.deviceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_IncomingRPCMessage.GDittoSource, rhs: Rpc_IncomingRPCMessage.GDittoSource) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_RPCMessageData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RPCMessageData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}sessionID\0\u{2}\u{2}timestamp\0\u{1}action\0\u{1}unencryptedData\0\u{1}bool1\0\u{1}bool2\0\u{1}encryptedData\0\u{1}bool3\0\u{2}\u{2}encryptedData2\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.timestamp) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.unencryptedData) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.bool1) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.bool2) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self.encryptedData) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.bool3) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.encryptedData2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    if self.action != .unspecified {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 4)
    }
    if !self.unencryptedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.unencryptedData, fieldNumber: 5)
    }
    if self.bool1 != false {
      try visitor.visitSingularBoolField(value: self.bool1, fieldNumber: 6)
    }
    if self.bool2 != false {
      try visitor.visitSingularBoolField(value: self.bool2, fieldNumber: 7)
    }
    if !self.encryptedData.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedData, fieldNumber: 8)
    }
    if self.bool3 != false {
      try visitor.visitSingularBoolField(value: self.bool3, fieldNumber: 9)
    }
    if !self.encryptedData2.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedData2, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_RPCMessageData, rhs: Rpc_RPCMessageData) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unencryptedData != rhs.unencryptedData {return false}
    if lhs.bool1 != rhs.bool1 {return false}
    if lhs.bool2 != rhs.bool2 {return false}
    if lhs.encryptedData != rhs.encryptedData {return false}
    if lhs.bool3 != rhs.bool3 {return false}
    if lhs.encryptedData2 != rhs.encryptedData2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_OutgoingRPCMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutgoingRPCMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mobile\0\u{1}data\0\u{1}auth\0\u{2}\u{2}TTL\0\u{2}\u{4}destRegistrationIDs\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mobile) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._auth) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.ttl) }()
      case 9: try { try decoder.decodeRepeatedStringField(value: &self.destRegistrationIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mobile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._auth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.ttl != 0 {
      try visitor.visitSingularInt64Field(value: self.ttl, fieldNumber: 5)
    }
    if !self.destRegistrationIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.destRegistrationIds, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_OutgoingRPCMessage, rhs: Rpc_OutgoingRPCMessage) -> Bool {
    if lhs._mobile != rhs._mobile {return false}
    if lhs._data != rhs._data {return false}
    if lhs._auth != rhs._auth {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.destRegistrationIds != rhs.destRegistrationIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_OutgoingRPCMessage.Auth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rpc_OutgoingRPCMessage.protoMessageName + ".Auth"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requestID\0\u{2}\u{5}tachyonAuthToken\0\u{1}configVersion\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.tachyonAuthToken) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._configVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.tachyonAuthToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.tachyonAuthToken, fieldNumber: 6)
    }
    try { if let v = self._configVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_OutgoingRPCMessage.Auth, rhs: Rpc_OutgoingRPCMessage.Auth) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.tachyonAuthToken != rhs.tachyonAuthToken {return false}
    if lhs._configVersion != rhs._configVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_OutgoingRPCMessage.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rpc_OutgoingRPCMessage.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requestID\0\u{1}bugleRoute\0\u{2}\u{a}messageData\0\u{2}\u{b}messageTypeData\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.bugleRoute) }()
      case 12: try { try decoder.decodeSingularBytesField(value: &self.messageData) }()
      case 23: try { try decoder.decodeSingularMessageField(value: &self._messageTypeData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if self.bugleRoute != .unknown {
      try visitor.visitSingularEnumField(value: self.bugleRoute, fieldNumber: 2)
    }
    if !self.messageData.isEmpty {
      try visitor.visitSingularBytesField(value: self.messageData, fieldNumber: 12)
    }
    try { if let v = self._messageTypeData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_OutgoingRPCMessage.DataMessage, rhs: Rpc_OutgoingRPCMessage.DataMessage) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.bugleRoute != rhs.bugleRoute {return false}
    if lhs.messageData != rhs.messageData {return false}
    if lhs._messageTypeData != rhs._messageTypeData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_OutgoingRPCMessage.DataMessage.TypeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rpc_OutgoingRPCMessage.DataMessage.protoMessageName + ".Type"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}emptyArr\0\u{1}messageType\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._emptyArr) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.messageType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._emptyArr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.messageType != .unknownMessageType {
      try visitor.visitSingularEnumField(value: self.messageType, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_OutgoingRPCMessage.DataMessage.TypeMessage, rhs: Rpc_OutgoingRPCMessage.DataMessage.TypeMessage) -> Bool {
    if lhs._emptyArr != rhs._emptyArr {return false}
    if lhs.messageType != rhs.messageType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_OutgoingRPCData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutgoingRPCData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requestID\0\u{1}action\0\u{1}unencryptedProtoData\0\u{2}\u{2}encryptedProtoData\0\u{1}sessionID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.unencryptedProtoData) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.encryptedProtoData) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if self.action != .unspecified {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    if !self.unencryptedProtoData.isEmpty {
      try visitor.visitSingularBytesField(value: self.unencryptedProtoData, fieldNumber: 3)
    }
    if !self.encryptedProtoData.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedProtoData, fieldNumber: 5)
    }
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_OutgoingRPCData, rhs: Rpc_OutgoingRPCData) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.action != rhs.action {return false}
    if lhs.unencryptedProtoData != rhs.unencryptedProtoData {return false}
    if lhs.encryptedProtoData != rhs.encryptedProtoData {return false}
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_OutgoingRPCResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".OutgoingRPCResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}someIdentifier\0\u{1}timestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._someIdentifier) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._timestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._someIdentifier {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timestamp {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_OutgoingRPCResponse, rhs: Rpc_OutgoingRPCResponse) -> Bool {
    if lhs._someIdentifier != rhs._someIdentifier {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Rpc_OutgoingRPCResponse.SomeIdentifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Rpc_OutgoingRPCResponse.protoMessageName + ".SomeIdentifier"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}someNumber\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.someNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.someNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.someNumber, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Rpc_OutgoingRPCResponse.SomeIdentifier, rhs: Rpc_OutgoingRPCResponse.SomeIdentifier) -> Bool {
    if lhs.someNumber != rhs.someNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
