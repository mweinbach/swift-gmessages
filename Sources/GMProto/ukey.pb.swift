// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ukey.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Ukey_Ukey2HandshakeCipher: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case reserved // = 0

  /// NIST P-256 used for ECDH, SHA512 used for commitment
  case p256Sha512 // = 100

  /// Curve 25519 used for ECDH, SHA512 used for commitment
  case curve25519Sha512 // = 200
  case UNRECOGNIZED(Int)

  public init() {
    self = .reserved
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .reserved
    case 100: self = .p256Sha512
    case 200: self = .curve25519Sha512
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .reserved: return 0
    case .p256Sha512: return 100
    case .curve25519Sha512: return 200
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Ukey_Ukey2HandshakeCipher] = [
    .reserved,
    .p256Sha512,
    .curve25519Sha512,
  ]

}

/// A list of supported public key types
public enum Ukey_PublicKeyType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknownPublicKeyType // = 0
  case ecP256 // = 1
  case rsa2048 // = 2

  /// 2048-bit MODP group 14, from RFC 3526
  case dh2048Modp // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownPublicKeyType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownPublicKeyType
    case 1: self = .ecP256
    case 2: self = .rsa2048
    case 3: self = .dh2048Modp
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownPublicKeyType: return 0
    case .ecP256: return 1
    case .rsa2048: return 2
    case .dh2048Modp: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Ukey_PublicKeyType] = [
    .unknownPublicKeyType,
    .ecP256,
    .rsa2048,
    .dh2048Modp,
  ]

}

public struct Ukey_Ukey2Message: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Identifies message type
  public var messageType: Ukey_Ukey2Message.TypeEnum = .unknownDoNotUse

  /// Actual message, to be parsed according to message_type
  public var messageData: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unknownDoNotUse // = 0
    case alert // = 1
    case clientInit // = 2
    case serverInit // = 3
    case clientFinish // = 4
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownDoNotUse
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownDoNotUse
      case 1: self = .alert
      case 2: self = .clientInit
      case 3: self = .serverInit
      case 4: self = .clientFinish
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownDoNotUse: return 0
      case .alert: return 1
      case .clientInit: return 2
      case .serverInit: return 3
      case .clientFinish: return 4
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ukey_Ukey2Message.TypeEnum] = [
      .unknownDoNotUse,
      .alert,
      .clientInit,
      .serverInit,
      .clientFinish,
    ]

  }

  public init() {}
}

public struct Ukey_Ukey2Alert: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Ukey_Ukey2Alert.AlertType = .unknownAlertType

  public var errorMessage: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum AlertType: SwiftProtobuf.Enum, Swift.CaseIterable {
    public typealias RawValue = Int
    case unknownAlertType // = 0

    /// Framing errors
    case badMessage // = 1

    /// message_type has an undefined value
    case badMessageType // = 2

    /// message_type received does not correspond to expected type at this stage of the protocol
    case incorrectMessage // = 3

    /// Could not deserialize message_data as per value in message_type
    case badMessageData // = 4

    /// ClientInit and ServerInit errors
    case badVersion // = 100

    /// Random data is missing or of incorrect length
    case badRandom // = 101

    /// No suitable handshake ciphers were found
    case badHandshakeCipher // = 102

    /// The next protocol is missing, unknown, or unsupported
    case badNextProtocol // = 103

    /// The public key could not be parsed
    case badPublicKey // = 104

    /// Other errors
    case internalError // = 200
    case UNRECOGNIZED(Int)

    public init() {
      self = .unknownAlertType
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknownAlertType
      case 1: self = .badMessage
      case 2: self = .badMessageType
      case 3: self = .incorrectMessage
      case 4: self = .badMessageData
      case 100: self = .badVersion
      case 101: self = .badRandom
      case 102: self = .badHandshakeCipher
      case 103: self = .badNextProtocol
      case 104: self = .badPublicKey
      case 200: self = .internalError
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .unknownAlertType: return 0
      case .badMessage: return 1
      case .badMessageType: return 2
      case .incorrectMessage: return 3
      case .badMessageData: return 4
      case .badVersion: return 100
      case .badRandom: return 101
      case .badHandshakeCipher: return 102
      case .badNextProtocol: return 103
      case .badPublicKey: return 104
      case .internalError: return 200
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    public static let allCases: [Ukey_Ukey2Alert.AlertType] = [
      .unknownAlertType,
      .badMessage,
      .badMessageType,
      .incorrectMessage,
      .badMessageData,
      .badVersion,
      .badRandom,
      .badHandshakeCipher,
      .badNextProtocol,
      .badPublicKey,
      .internalError,
    ]

  }

  public init() {}
}

public struct Ukey_Ukey2ClientInit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// highest supported version for rollback protection
  public var version: Int32 = 0

  /// random bytes for replay/reuse protection
  public var random: Data = Data()

  public var cipherCommitments: [Ukey_Ukey2ClientInit.CipherCommitment] = []

  /// Next protocol that the client wants to speak.
  public var nextProtocol: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// One commitment (hash of ClientFinished containing public key) per supported cipher
  public struct CipherCommitment: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var handshakeCipher: Ukey_Ukey2HandshakeCipher = .reserved

    public var commitment: Data = Data()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Ukey_Ukey2ServerInit: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// highest supported version for rollback protection
  public var version: Int32 = 0

  /// random bytes for replay/reuse protection
  public var random: Data = Data()

  /// Selected Cipher and corresponding public key
  public var handshakeCipher: Ukey_Ukey2HandshakeCipher = .reserved

  public var publicKey: Ukey_GenericPublicKey {
    get {return _publicKey ?? Ukey_GenericPublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {self._publicKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _publicKey: Ukey_GenericPublicKey? = nil
}

public struct Ukey_Ukey2ClientFinished: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// public key matching selected handshake cipher
  public var publicKey: Ukey_GenericPublicKey {
    get {return _publicKey ?? Ukey_GenericPublicKey()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  public var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  public mutating func clearPublicKey() {self._publicKey = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _publicKey: Ukey_GenericPublicKey? = nil
}

/// A convenience proto for encoding NIST P-256 elliptic curve public keys
public struct Ukey_EcP256PublicKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// x and y are encoded in big-endian two's complement (slightly wasteful)
  /// Client MUST verify (x,y) is a valid point on NIST P256
  public var x: Data = Data()

  public var y: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A convenience proto for encoding RSA public keys with small exponents
public struct Ukey_SimpleRsaPublicKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Encoded in big-endian two's complement
  public var n: Data = Data()

  public var e: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// A convenience proto for encoding Diffie-Hellman public keys,
/// for use only when Elliptic Curve based key exchanges are not possible.
/// (Note that the group parameters must be specified separately)
public struct Ukey_DhPublicKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Big-endian two's complement encoded group element
  public var y: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Ukey_GenericPublicKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Ukey_PublicKeyType = .unknownPublicKeyType

  public var publicKey: Ukey_GenericPublicKey.OneOf_PublicKey? = nil

  public var ecP256PublicKey: Ukey_EcP256PublicKey {
    get {
      if case .ecP256PublicKey(let v)? = publicKey {return v}
      return Ukey_EcP256PublicKey()
    }
    set {publicKey = .ecP256PublicKey(newValue)}
  }

  public var rsa2048PublicKey: Ukey_SimpleRsaPublicKey {
    get {
      if case .rsa2048PublicKey(let v)? = publicKey {return v}
      return Ukey_SimpleRsaPublicKey()
    }
    set {publicKey = .rsa2048PublicKey(newValue)}
  }

  /// Use only as a last resort
  public var dh2048PublicKey: Ukey_DhPublicKey {
    get {
      if case .dh2048PublicKey(let v)? = publicKey {return v}
      return Ukey_DhPublicKey()
    }
    set {publicKey = .dh2048PublicKey(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_PublicKey: Equatable, Sendable {
    case ecP256PublicKey(Ukey_EcP256PublicKey)
    case rsa2048PublicKey(Ukey_SimpleRsaPublicKey)
    /// Use only as a last resort
    case dh2048PublicKey(Ukey_DhPublicKey)

  }

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ukey"

extension Ukey_Ukey2HandshakeCipher: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0RESERVED\0\u{2}d\u{1}P256_SHA512\0\u{2}d\u{1}CURVE25519_SHA512\0")
}

extension Ukey_PublicKeyType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN_PUBLIC_KEY_TYPE\0\u{1}EC_P256\0\u{1}RSA2048\0\u{1}DH2048_MODP\0")
}

extension Ukey_Ukey2Message: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ukey2Message"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}message_type\0\u{3}message_data\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.messageType) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.messageData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageType != .unknownDoNotUse {
      try visitor.visitSingularEnumField(value: self.messageType, fieldNumber: 1)
    }
    if !self.messageData.isEmpty {
      try visitor.visitSingularBytesField(value: self.messageData, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ukey_Ukey2Message, rhs: Ukey_Ukey2Message) -> Bool {
    if lhs.messageType != rhs.messageType {return false}
    if lhs.messageData != rhs.messageData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ukey_Ukey2Message.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN_DO_NOT_USE\0\u{1}ALERT\0\u{1}CLIENT_INIT\0\u{1}SERVER_INIT\0\u{1}CLIENT_FINISH\0")
}

extension Ukey_Ukey2Alert: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ukey2Alert"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{3}error_message\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .unknownAlertType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ukey_Ukey2Alert, rhs: Ukey_Ukey2Alert) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ukey_Ukey2Alert.AlertType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN_ALERT_TYPE\0\u{1}BAD_MESSAGE\0\u{1}BAD_MESSAGE_TYPE\0\u{1}INCORRECT_MESSAGE\0\u{1}BAD_MESSAGE_DATA\0\u{2}`\u{1}BAD_VERSION\0\u{1}BAD_RANDOM\0\u{1}BAD_HANDSHAKE_CIPHER\0\u{1}BAD_NEXT_PROTOCOL\0\u{1}BAD_PUBLIC_KEY\0\u{2}`\u{1}INTERNAL_ERROR\0")
}

extension Ukey_Ukey2ClientInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ukey2ClientInit"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{1}random\0\u{3}cipher_commitments\0\u{3}next_protocol\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.random) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.cipherCommitments) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.nextProtocol) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.random.isEmpty {
      try visitor.visitSingularBytesField(value: self.random, fieldNumber: 2)
    }
    if !self.cipherCommitments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cipherCommitments, fieldNumber: 3)
    }
    if !self.nextProtocol.isEmpty {
      try visitor.visitSingularStringField(value: self.nextProtocol, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ukey_Ukey2ClientInit, rhs: Ukey_Ukey2ClientInit) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.random != rhs.random {return false}
    if lhs.cipherCommitments != rhs.cipherCommitments {return false}
    if lhs.nextProtocol != rhs.nextProtocol {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ukey_Ukey2ClientInit.CipherCommitment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Ukey_Ukey2ClientInit.protoMessageName + ".CipherCommitment"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}handshake_cipher\0\u{1}commitment\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.handshakeCipher) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.commitment) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.handshakeCipher != .reserved {
      try visitor.visitSingularEnumField(value: self.handshakeCipher, fieldNumber: 1)
    }
    if !self.commitment.isEmpty {
      try visitor.visitSingularBytesField(value: self.commitment, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ukey_Ukey2ClientInit.CipherCommitment, rhs: Ukey_Ukey2ClientInit.CipherCommitment) -> Bool {
    if lhs.handshakeCipher != rhs.handshakeCipher {return false}
    if lhs.commitment != rhs.commitment {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ukey_Ukey2ServerInit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ukey2ServerInit"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}version\0\u{1}random\0\u{3}handshake_cipher\0\u{3}public_key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.version) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.random) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.handshakeCipher) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 1)
    }
    if !self.random.isEmpty {
      try visitor.visitSingularBytesField(value: self.random, fieldNumber: 2)
    }
    if self.handshakeCipher != .reserved {
      try visitor.visitSingularEnumField(value: self.handshakeCipher, fieldNumber: 3)
    }
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ukey_Ukey2ServerInit, rhs: Ukey_Ukey2ServerInit) -> Bool {
    if lhs.version != rhs.version {return false}
    if lhs.random != rhs.random {return false}
    if lhs.handshakeCipher != rhs.handshakeCipher {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ukey_Ukey2ClientFinished: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Ukey2ClientFinished"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}public_key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._publicKey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._publicKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ukey_Ukey2ClientFinished, rhs: Ukey_Ukey2ClientFinished) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ukey_EcP256PublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EcP256PublicKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}x\0\u{1}y\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.x) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.y) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.x.isEmpty {
      try visitor.visitSingularBytesField(value: self.x, fieldNumber: 1)
    }
    if !self.y.isEmpty {
      try visitor.visitSingularBytesField(value: self.y, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ukey_EcP256PublicKey, rhs: Ukey_EcP256PublicKey) -> Bool {
    if lhs.x != rhs.x {return false}
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ukey_SimpleRsaPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SimpleRsaPublicKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}n\0\u{1}e\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.n) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.e) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.n.isEmpty {
      try visitor.visitSingularBytesField(value: self.n, fieldNumber: 1)
    }
    if self.e != 0 {
      try visitor.visitSingularInt32Field(value: self.e, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ukey_SimpleRsaPublicKey, rhs: Ukey_SimpleRsaPublicKey) -> Bool {
    if lhs.n != rhs.n {return false}
    if lhs.e != rhs.e {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ukey_DhPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DhPublicKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}y\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.y) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.y.isEmpty {
      try visitor.visitSingularBytesField(value: self.y, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ukey_DhPublicKey, rhs: Ukey_DhPublicKey) -> Bool {
    if lhs.y != rhs.y {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ukey_GenericPublicKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GenericPublicKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{3}ec_p256_public_key\0\u{3}rsa2048_public_key\0\u{3}dh2048_public_key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try {
        var v: Ukey_EcP256PublicKey?
        var hadOneofValue = false
        if let current = self.publicKey {
          hadOneofValue = true
          if case .ecP256PublicKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.publicKey = .ecP256PublicKey(v)
        }
      }()
      case 3: try {
        var v: Ukey_SimpleRsaPublicKey?
        var hadOneofValue = false
        if let current = self.publicKey {
          hadOneofValue = true
          if case .rsa2048PublicKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.publicKey = .rsa2048PublicKey(v)
        }
      }()
      case 4: try {
        var v: Ukey_DhPublicKey?
        var hadOneofValue = false
        if let current = self.publicKey {
          hadOneofValue = true
          if case .dh2048PublicKey(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.publicKey = .dh2048PublicKey(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .unknownPublicKeyType {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    switch self.publicKey {
    case .ecP256PublicKey?: try {
      guard case .ecP256PublicKey(let v)? = self.publicKey else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .rsa2048PublicKey?: try {
      guard case .rsa2048PublicKey(let v)? = self.publicKey else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .dh2048PublicKey?: try {
      guard case .dh2048PublicKey(let v)? = self.publicKey else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Ukey_GenericPublicKey, rhs: Ukey_GenericPublicKey) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
