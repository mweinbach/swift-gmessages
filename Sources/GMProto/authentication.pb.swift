// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: authentication.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Authentication_BrowserType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknownBrowserType // = 0
  case other // = 1
  case chrome // = 2
  case firefox // = 3
  case safari // = 4
  case opera // = 5
  case ie // = 6
  case edge // = 7
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownBrowserType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownBrowserType
    case 1: self = .other
    case 2: self = .chrome
    case 3: self = .firefox
    case 4: self = .safari
    case 5: self = .opera
    case 6: self = .ie
    case 7: self = .edge
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownBrowserType: return 0
    case .other: return 1
    case .chrome: return 2
    case .firefox: return 3
    case .safari: return 4
    case .opera: return 5
    case .ie: return 6
    case .edge: return 7
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Authentication_BrowserType] = [
    .unknownBrowserType,
    .other,
    .chrome,
    .firefox,
    .safari,
    .opera,
    .ie,
    .edge,
  ]

}

public enum Authentication_DeviceType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknownDeviceType // = 0
  case web // = 1
  case tablet // = 2
  case pwa // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknownDeviceType
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownDeviceType
    case 1: self = .web
    case 2: self = .tablet
    case 3: self = .pwa
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknownDeviceType: return 0
    case .web: return 1
    case .tablet: return 2
    case .pwa: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Authentication_DeviceType] = [
    .unknownDeviceType,
    .web,
    .tablet,
    .pwa,
  ]

}

public enum Authentication_GaiaPairingErrorCode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case none // = 0
  case ukey2AlertError // = 1
  case requestOutOfDate // = 2
  case requestNotReceivedQuickly // = 3
  case invalidUser // = 4
  case wrongVerificationCodeSelected // = 5
  case verificationTimedOut // = 6
  case userCanceledVerification // = 7
  case ukey2OtherError // = 8
  case verificationEmojiDownloadFailed // = 9
  case notLatestAttempt // = 10
  case verificationDataServiceNotPresent // = 11
  case verificationIntentsNotPresent // = 12
  case wrongUkey2MessageType // = 13
  case requestCompleteWithUnknownResult // = 14
  case phoneNotAwaitingConfirmation // = 15
  case ukey2MessageMissing // = 16
  case clientInitTimeout // = 17
  case clientFinishedTimeout // = 18
  case unknown // = 19
  case webCancelButtonClicked // = 20
  case webBackButtonClicked // = 21
  case webLeavePairPage // = 22
  case newRequestWhileWaitingForVerification // = 23
  case ukey2HandshakeError // = 24
  case verificationCodeRevisionMismatch // = 25
  case userCanceledVerificationOnWeb // = 26
  case userDeniedVerificationNotMe // = 27
  case keyDerivationRevisionMismatch // = 28
  case cmsBackupKeyNotFound // = 29
  case unableToEncryptCmsBackupKey // = 30
  case unableToDecryptCmsBackupKey // = 31
  case UNRECOGNIZED(Int)

  public init() {
    self = .none
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .ukey2AlertError
    case 2: self = .requestOutOfDate
    case 3: self = .requestNotReceivedQuickly
    case 4: self = .invalidUser
    case 5: self = .wrongVerificationCodeSelected
    case 6: self = .verificationTimedOut
    case 7: self = .userCanceledVerification
    case 8: self = .ukey2OtherError
    case 9: self = .verificationEmojiDownloadFailed
    case 10: self = .notLatestAttempt
    case 11: self = .verificationDataServiceNotPresent
    case 12: self = .verificationIntentsNotPresent
    case 13: self = .wrongUkey2MessageType
    case 14: self = .requestCompleteWithUnknownResult
    case 15: self = .phoneNotAwaitingConfirmation
    case 16: self = .ukey2MessageMissing
    case 17: self = .clientInitTimeout
    case 18: self = .clientFinishedTimeout
    case 19: self = .unknown
    case 20: self = .webCancelButtonClicked
    case 21: self = .webBackButtonClicked
    case 22: self = .webLeavePairPage
    case 23: self = .newRequestWhileWaitingForVerification
    case 24: self = .ukey2HandshakeError
    case 25: self = .verificationCodeRevisionMismatch
    case 26: self = .userCanceledVerificationOnWeb
    case 27: self = .userDeniedVerificationNotMe
    case 28: self = .keyDerivationRevisionMismatch
    case 29: self = .cmsBackupKeyNotFound
    case 30: self = .unableToEncryptCmsBackupKey
    case 31: self = .unableToDecryptCmsBackupKey
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .none: return 0
    case .ukey2AlertError: return 1
    case .requestOutOfDate: return 2
    case .requestNotReceivedQuickly: return 3
    case .invalidUser: return 4
    case .wrongVerificationCodeSelected: return 5
    case .verificationTimedOut: return 6
    case .userCanceledVerification: return 7
    case .ukey2OtherError: return 8
    case .verificationEmojiDownloadFailed: return 9
    case .notLatestAttempt: return 10
    case .verificationDataServiceNotPresent: return 11
    case .verificationIntentsNotPresent: return 12
    case .wrongUkey2MessageType: return 13
    case .requestCompleteWithUnknownResult: return 14
    case .phoneNotAwaitingConfirmation: return 15
    case .ukey2MessageMissing: return 16
    case .clientInitTimeout: return 17
    case .clientFinishedTimeout: return 18
    case .unknown: return 19
    case .webCancelButtonClicked: return 20
    case .webBackButtonClicked: return 21
    case .webLeavePairPage: return 22
    case .newRequestWhileWaitingForVerification: return 23
    case .ukey2HandshakeError: return 24
    case .verificationCodeRevisionMismatch: return 25
    case .userCanceledVerificationOnWeb: return 26
    case .userDeniedVerificationNotMe: return 27
    case .keyDerivationRevisionMismatch: return 28
    case .cmsBackupKeyNotFound: return 29
    case .unableToEncryptCmsBackupKey: return 30
    case .unableToDecryptCmsBackupKey: return 31
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Authentication_GaiaPairingErrorCode] = [
    .none,
    .ukey2AlertError,
    .requestOutOfDate,
    .requestNotReceivedQuickly,
    .invalidUser,
    .wrongVerificationCodeSelected,
    .verificationTimedOut,
    .userCanceledVerification,
    .ukey2OtherError,
    .verificationEmojiDownloadFailed,
    .notLatestAttempt,
    .verificationDataServiceNotPresent,
    .verificationIntentsNotPresent,
    .wrongUkey2MessageType,
    .requestCompleteWithUnknownResult,
    .phoneNotAwaitingConfirmation,
    .ukey2MessageMissing,
    .clientInitTimeout,
    .clientFinishedTimeout,
    .unknown,
    .webCancelButtonClicked,
    .webBackButtonClicked,
    .webLeavePairPage,
    .newRequestWhileWaitingForVerification,
    .ukey2HandshakeError,
    .verificationCodeRevisionMismatch,
    .userCanceledVerificationOnWeb,
    .userDeniedVerificationNotMe,
    .keyDerivationRevisionMismatch,
    .cmsBackupKeyNotFound,
    .unableToEncryptCmsBackupKey,
    .unableToDecryptCmsBackupKey,
  ]

}

public struct Authentication_BrowserDetails: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userAgent: String = String()

  public var browserType: Authentication_BrowserType = .unknownBrowserType

  public var os: String = String()

  public var deviceType: Authentication_DeviceType = .unknownDeviceType

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Authentication_Device: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var userID: Int64 = 0

  public var sourceID: String = String()

  public var network: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Authentication_ConfigVersion: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var year: Int32 = 0

  public var month: Int32 = 0

  public var day: Int32 = 0

  public var v1: Int32 = 0

  public var v2: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Authentication_SignInGaiaRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var authMessage: Authentication_AuthMessage {
    get {return _authMessage ?? Authentication_AuthMessage()}
    set {_authMessage = newValue}
  }
  /// Returns true if `authMessage` has been explicitly set.
  public var hasAuthMessage: Bool {return self._authMessage != nil}
  /// Clears the value of `authMessage`. Subsequent reads from it will return its default value.
  public mutating func clearAuthMessage() {self._authMessage = nil}

  public var inner: Authentication_SignInGaiaRequest.Inner {
    get {return _inner ?? Authentication_SignInGaiaRequest.Inner()}
    set {_inner = newValue}
  }
  /// Returns true if `inner` has been explicitly set.
  public var hasInner: Bool {return self._inner != nil}
  /// Clears the value of `inner`. Subsequent reads from it will return its default value.
  public mutating func clearInner() {self._inner = nil}

  public var unknownInt3: Int32 = 0

  public var network: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Inner: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var deviceID: Authentication_SignInGaiaRequest.Inner.DeviceID {
      get {return _deviceID ?? Authentication_SignInGaiaRequest.Inner.DeviceID()}
      set {_deviceID = newValue}
    }
    /// Returns true if `deviceID` has been explicitly set.
    public var hasDeviceID: Bool {return self._deviceID != nil}
    /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
    public mutating func clearDeviceID() {self._deviceID = nil}

    public var someData: Authentication_SignInGaiaRequest.Inner.DataMessage {
      get {return _someData ?? Authentication_SignInGaiaRequest.Inner.DataMessage()}
      set {_someData = newValue}
    }
    /// Returns true if `someData` has been explicitly set.
    public var hasSomeData: Bool {return self._someData != nil}
    /// Clears the value of `someData`. Subsequent reads from it will return its default value.
    public mutating func clearSomeData() {self._someData = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct DeviceID: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// 3
      public var unknownInt1: Int32 = 0

      /// messages-web-{uuid without dashes}
      public var deviceID: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct DataMessage: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// maybe an encryption key?
      public var someData: Data = Data()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}

    fileprivate var _deviceID: Authentication_SignInGaiaRequest.Inner.DeviceID? = nil
    fileprivate var _someData: Authentication_SignInGaiaRequest.Inner.DataMessage? = nil
  }

  public init() {}

  fileprivate var _authMessage: Authentication_AuthMessage? = nil
  fileprivate var _inner: Authentication_SignInGaiaRequest.Inner? = nil
}

public struct Authentication_SignInGaiaResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var header: Authentication_SignInGaiaResponse.Header {
    get {return _header ?? Authentication_SignInGaiaResponse.Header()}
    set {_header = newValue}
  }
  /// Returns true if `header` has been explicitly set.
  public var hasHeader: Bool {return self._header != nil}
  /// Clears the value of `header`. Subsequent reads from it will return its default value.
  public mutating func clearHeader() {self._header = nil}

  public var maybeBrowserUuid: String = String()

  public var deviceData: Authentication_SignInGaiaResponse.DeviceData {
    get {return _deviceData ?? Authentication_SignInGaiaResponse.DeviceData()}
    set {_deviceData = newValue}
  }
  /// Returns true if `deviceData` has been explicitly set.
  public var hasDeviceData: Bool {return self._deviceData != nil}
  /// Clears the value of `deviceData`. Subsequent reads from it will return its default value.
  public mutating func clearDeviceData() {self._deviceData = nil}

  public var tokenData: Authentication_TokenData {
    get {return _tokenData ?? Authentication_TokenData()}
    set {_tokenData = newValue}
  }
  /// Returns true if `tokenData` has been explicitly set.
  public var hasTokenData: Bool {return self._tokenData != nil}
  /// Clears the value of `tokenData`. Subsequent reads from it will return its default value.
  public mutating func clearTokenData() {self._tokenData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Header: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var unknownInt2: UInt64 = 0

    public var unknownTimestamp: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct DeviceData: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var deviceWrapper: Authentication_SignInGaiaResponse.DeviceData.DeviceWrapper {
      get {return _deviceWrapper ?? Authentication_SignInGaiaResponse.DeviceData.DeviceWrapper()}
      set {_deviceWrapper = newValue}
    }
    /// Returns true if `deviceWrapper` has been explicitly set.
    public var hasDeviceWrapper: Bool {return self._deviceWrapper != nil}
    /// Clears the value of `deviceWrapper`. Subsequent reads from it will return its default value.
    public mutating func clearDeviceWrapper() {self._deviceWrapper = nil}

    public var unknownItems2: [Authentication_RPCGaiaData.UnknownContainer.Item2.Item1] = []

    /// index 4 is some unknown field with no real data
    public var unknownItems3: [Authentication_RPCGaiaData.UnknownContainer.Item4] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct DeviceWrapper: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var device: Authentication_Device {
        get {return _device ?? Authentication_Device()}
        set {_device = newValue}
      }
      /// Returns true if `device` has been explicitly set.
      public var hasDevice: Bool {return self._device != nil}
      /// Clears the value of `device`. Subsequent reads from it will return its default value.
      public mutating func clearDevice() {self._device = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}

      fileprivate var _device: Authentication_Device? = nil
    }

    public init() {}

    fileprivate var _deviceWrapper: Authentication_SignInGaiaResponse.DeviceData.DeviceWrapper? = nil
  }

  public init() {}

  fileprivate var _header: Authentication_SignInGaiaResponse.Header? = nil
  fileprivate var _deviceData: Authentication_SignInGaiaResponse.DeviceData? = nil
  fileprivate var _tokenData: Authentication_TokenData? = nil
}

public struct Authentication_GaiaPairingRequestContainer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pairingAttemptID: String = String()

  public var browserDetails: Authentication_BrowserDetails {
    get {return _browserDetails ?? Authentication_BrowserDetails()}
    set {_browserDetails = newValue}
  }
  /// Returns true if `browserDetails` has been explicitly set.
  public var hasBrowserDetails: Bool {return self._browserDetails != nil}
  /// Clears the value of `browserDetails`. Subsequent reads from it will return its default value.
  public mutating func clearBrowserDetails() {self._browserDetails = nil}

  public var startTimestamp: Int64 = 0

  public var data: Data = Data()

  public var proposedVerificationCodeVersion: Int32 = 0

  public var proposedKeyDerivationVersion: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _browserDetails: Authentication_BrowserDetails? = nil
}

public struct Authentication_GaiaPairingResponseContainer: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var finishErrorType: Int32 = 0

  public var finishErrorCode: Authentication_GaiaPairingErrorCode = .none

  /// For init, 1
  public var unknownInt3: Int32 = 0

  public var sessionUuid: String = String()

  public var data: Data = Data()

  public var confirmedVerificationCodeVersion: Int32 = 0

  public var confirmedKeyDerivationVersion: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Authentication_RevokeGaiaPairingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pairingAttemptID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Authentication_RPCGaiaData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 9
  public var command: Int32 = 0

  public var maybeServerData: Authentication_RPCGaiaData.UnknownContainer {
    get {return _maybeServerData ?? Authentication_RPCGaiaData.UnknownContainer()}
    set {_maybeServerData = newValue}
  }
  /// Returns true if `maybeServerData` has been explicitly set.
  public var hasMaybeServerData: Bool {return self._maybeServerData != nil}
  /// Clears the value of `maybeServerData`. Subsequent reads from it will return its default value.
  public mutating func clearMaybeServerData() {self._maybeServerData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct UnknownContainer: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var item2: Authentication_RPCGaiaData.UnknownContainer.Item2 {
      get {return _item2 ?? Authentication_RPCGaiaData.UnknownContainer.Item2()}
      set {_item2 = newValue}
    }
    /// Returns true if `item2` has been explicitly set.
    public var hasItem2: Bool {return self._item2 != nil}
    /// Clears the value of `item2`. Subsequent reads from it will return its default value.
    public mutating func clearItem2() {self._item2 = nil}

    /// pairing timestamp?
    public var unknownTimestampMicroseconds: Int64 = 0

    public var item4: [Authentication_RPCGaiaData.UnknownContainer.Item4] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct Item2: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var item1: [Authentication_RPCGaiaData.UnknownContainer.Item2.Item1] = []

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Item1: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        public var destOrSourceUuid: String = String()

        /// 1 for destination device, 6 for local device?
        public var unknownInt4: Int32 = 0

        public var languageCode: String = String()

        public var unknownBigInt7: UInt64 = 0

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}
    }

    public struct Item4: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var destOrSourceUuid: String = String()

      /// 1 for destination device, 6 for local device?
      public var unknownInt3: Int32 = 0

      /// always 6?
      public var unknownInt4: Int32 = 0

      /// maybe device creation ts?
      public var unknownTimestampMicroseconds: Int64 = 0

      public var item8: Authentication_RPCGaiaData.UnknownContainer.Item4.Item8 {
        get {return _item8 ?? Authentication_RPCGaiaData.UnknownContainer.Item4.Item8()}
        set {_item8 = newValue}
      }
      /// Returns true if `item8` has been explicitly set.
      public var hasItem8: Bool {return self._item8 != nil}
      /// Clears the value of `item8`. Subsequent reads from it will return its default value.
      public mutating func clearItem8() {self._item8 = nil}

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public struct Item8: Sendable {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.

        /// present for destination device?
        public var unknownInt1: Int32 = 0

        /// present for destination device?
        public var unknownTimestamp: Int32 = 0

        /// present for local device?
        public var unknownBytes: Data = Data()

        public var unknownFields = SwiftProtobuf.UnknownStorage()

        public init() {}
      }

      public init() {}

      fileprivate var _item8: Authentication_RPCGaiaData.UnknownContainer.Item4.Item8? = nil
    }

    public init() {}

    fileprivate var _item2: Authentication_RPCGaiaData.UnknownContainer.Item2? = nil
  }

  public init() {}

  fileprivate var _maybeServerData: Authentication_RPCGaiaData.UnknownContainer? = nil
}

public struct Authentication_AuthenticationContainer: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var authMessage: Authentication_AuthMessage {
    get {return _storage._authMessage ?? Authentication_AuthMessage()}
    set {_uniqueStorage()._authMessage = newValue}
  }
  /// Returns true if `authMessage` has been explicitly set.
  public var hasAuthMessage: Bool {return _storage._authMessage != nil}
  /// Clears the value of `authMessage`. Subsequent reads from it will return its default value.
  public mutating func clearAuthMessage() {_uniqueStorage()._authMessage = nil}

  public var browserDetails: Authentication_BrowserDetails {
    get {return _storage._browserDetails ?? Authentication_BrowserDetails()}
    set {_uniqueStorage()._browserDetails = newValue}
  }
  /// Returns true if `browserDetails` has been explicitly set.
  public var hasBrowserDetails: Bool {return _storage._browserDetails != nil}
  /// Clears the value of `browserDetails`. Subsequent reads from it will return its default value.
  public mutating func clearBrowserDetails() {_uniqueStorage()._browserDetails = nil}

  public var data: OneOf_Data? {
    get {return _storage._data}
    set {_uniqueStorage()._data = newValue}
  }

  public var keyData: Authentication_KeyData {
    get {
      if case .keyData(let v)? = _storage._data {return v}
      return Authentication_KeyData()
    }
    set {_uniqueStorage()._data = .keyData(newValue)}
  }

  public var deviceData: Authentication_CurrentDeviceData {
    get {
      if case .deviceData(let v)? = _storage._data {return v}
      return Authentication_CurrentDeviceData()
    }
    set {_uniqueStorage()._data = .deviceData(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_Data: Equatable, Sendable {
    case keyData(Authentication_KeyData)
    case deviceData(Authentication_CurrentDeviceData)

  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Authentication_AuthMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var requestID: String = String()

  public var network: String = String()

  public var tachyonAuthToken: Data = Data()

  public var configVersion: Authentication_ConfigVersion {
    get {return _configVersion ?? Authentication_ConfigVersion()}
    set {_configVersion = newValue}
  }
  /// Returns true if `configVersion` has been explicitly set.
  public var hasConfigVersion: Bool {return self._configVersion != nil}
  /// Clears the value of `configVersion`. Subsequent reads from it will return its default value.
  public mutating func clearConfigVersion() {self._configVersion = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _configVersion: Authentication_ConfigVersion? = nil
}

public struct Authentication_RevokeRelayPairingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var authMessage: Authentication_AuthMessage {
    get {return _authMessage ?? Authentication_AuthMessage()}
    set {_authMessage = newValue}
  }
  /// Returns true if `authMessage` has been explicitly set.
  public var hasAuthMessage: Bool {return self._authMessage != nil}
  /// Clears the value of `authMessage`. Subsequent reads from it will return its default value.
  public mutating func clearAuthMessage() {self._authMessage = nil}

  public var browser: Authentication_Device {
    get {return _browser ?? Authentication_Device()}
    set {_browser = newValue}
  }
  /// Returns true if `browser` has been explicitly set.
  public var hasBrowser: Bool {return self._browser != nil}
  /// Clears the value of `browser`. Subsequent reads from it will return its default value.
  public mutating func clearBrowser() {self._browser = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _authMessage: Authentication_AuthMessage? = nil
  fileprivate var _browser: Authentication_Device? = nil
}

/// field 1 is an object with an unknown int64 in field 2
public struct Authentication_RevokeRelayPairingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Authentication_RegisterRefreshRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var messageAuth: Authentication_AuthMessage {
    get {return _storage._messageAuth ?? Authentication_AuthMessage()}
    set {_uniqueStorage()._messageAuth = newValue}
  }
  /// Returns true if `messageAuth` has been explicitly set.
  public var hasMessageAuth: Bool {return _storage._messageAuth != nil}
  /// Clears the value of `messageAuth`. Subsequent reads from it will return its default value.
  public mutating func clearMessageAuth() {_uniqueStorage()._messageAuth = nil}

  public var currBrowserDevice: Authentication_Device {
    get {return _storage._currBrowserDevice ?? Authentication_Device()}
    set {_uniqueStorage()._currBrowserDevice = newValue}
  }
  /// Returns true if `currBrowserDevice` has been explicitly set.
  public var hasCurrBrowserDevice: Bool {return _storage._currBrowserDevice != nil}
  /// Clears the value of `currBrowserDevice`. Subsequent reads from it will return its default value.
  public mutating func clearCurrBrowserDevice() {_uniqueStorage()._currBrowserDevice = nil}

  public var unixTimestamp: Int64 {
    get {return _storage._unixTimestamp}
    set {_uniqueStorage()._unixTimestamp = newValue}
  }

  public var signature: Data {
    get {return _storage._signature}
    set {_uniqueStorage()._signature = newValue}
  }

  public var parameters: Authentication_RegisterRefreshRequest.Parameters {
    get {return _storage._parameters ?? Authentication_RegisterRefreshRequest.Parameters()}
    set {_uniqueStorage()._parameters = newValue}
  }
  /// Returns true if `parameters` has been explicitly set.
  public var hasParameters: Bool {return _storage._parameters != nil}
  /// Clears the value of `parameters`. Subsequent reads from it will return its default value.
  public mutating func clearParameters() {_uniqueStorage()._parameters = nil}

  public var messageType: Int32 {
    get {return _storage._messageType}
    set {_uniqueStorage()._messageType = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct PushRegistration: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: String = String()

    public var url: String = String()

    public var p256Dh: String = String()

    public var auth: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct MoreParameters: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var three: Int32 = 0

    public var pushReg: Authentication_RegisterRefreshRequest.PushRegistration {
      get {return _pushReg ?? Authentication_RegisterRefreshRequest.PushRegistration()}
      set {_pushReg = newValue}
    }
    /// Returns true if `pushReg` has been explicitly set.
    public var hasPushReg: Bool {return self._pushReg != nil}
    /// Clears the value of `pushReg`. Subsequent reads from it will return its default value.
    public mutating func clearPushReg() {self._pushReg = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _pushReg: Authentication_RegisterRefreshRequest.PushRegistration? = nil
  }

  public struct Parameters: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var emptyArr: Util_EmptyArr {
      get {return _emptyArr ?? Util_EmptyArr()}
      set {_emptyArr = newValue}
    }
    /// Returns true if `emptyArr` has been explicitly set.
    public var hasEmptyArr: Bool {return self._emptyArr != nil}
    /// Clears the value of `emptyArr`. Subsequent reads from it will return its default value.
    public mutating func clearEmptyArr() {self._emptyArr = nil}

    public var moreParameters: Authentication_RegisterRefreshRequest.MoreParameters {
      get {return _moreParameters ?? Authentication_RegisterRefreshRequest.MoreParameters()}
      set {_moreParameters = newValue}
    }
    /// Returns true if `moreParameters` has been explicitly set.
    public var hasMoreParameters: Bool {return self._moreParameters != nil}
    /// Clears the value of `moreParameters`. Subsequent reads from it will return its default value.
    public mutating func clearMoreParameters() {self._moreParameters = nil}

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _emptyArr: Util_EmptyArr? = nil
    fileprivate var _moreParameters: Authentication_RegisterRefreshRequest.MoreParameters? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Authentication_RegisterRefreshResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tokenData: Authentication_TokenData {
    get {return _tokenData ?? Authentication_TokenData()}
    set {_tokenData = newValue}
  }
  /// Returns true if `tokenData` has been explicitly set.
  public var hasTokenData: Bool {return self._tokenData != nil}
  /// Clears the value of `tokenData`. Subsequent reads from it will return its default value.
  public mutating func clearTokenData() {self._tokenData = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _tokenData: Authentication_TokenData? = nil
}

public struct Authentication_RegisterPhoneRelayResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coordinates: Authentication_CoordinateMessage {
    get {return _coordinates ?? Authentication_CoordinateMessage()}
    set {_coordinates = newValue}
  }
  /// Returns true if `coordinates` has been explicitly set.
  public var hasCoordinates: Bool {return self._coordinates != nil}
  /// Clears the value of `coordinates`. Subsequent reads from it will return its default value.
  public mutating func clearCoordinates() {self._coordinates = nil}

  public var browser: Authentication_Device {
    get {return _browser ?? Authentication_Device()}
    set {_browser = newValue}
  }
  /// Returns true if `browser` has been explicitly set.
  public var hasBrowser: Bool {return self._browser != nil}
  /// Clears the value of `browser`. Subsequent reads from it will return its default value.
  public mutating func clearBrowser() {self._browser = nil}

  public var pairingKey: Data = Data()

  public var validFor: Int64 = 0

  public var authKeyData: Authentication_TokenData {
    get {return _authKeyData ?? Authentication_TokenData()}
    set {_authKeyData = newValue}
  }
  /// Returns true if `authKeyData` has been explicitly set.
  public var hasAuthKeyData: Bool {return self._authKeyData != nil}
  /// Clears the value of `authKeyData`. Subsequent reads from it will return its default value.
  public mutating func clearAuthKeyData() {self._authKeyData = nil}

  public var responseID: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coordinates: Authentication_CoordinateMessage? = nil
  fileprivate var _browser: Authentication_Device? = nil
  fileprivate var _authKeyData: Authentication_TokenData? = nil
}

public struct Authentication_CoordinateMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coord1: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Authentication_RefreshPhoneRelayResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coordinates: Authentication_CoordinateMessage {
    get {return _coordinates ?? Authentication_CoordinateMessage()}
    set {_coordinates = newValue}
  }
  /// Returns true if `coordinates` has been explicitly set.
  public var hasCoordinates: Bool {return self._coordinates != nil}
  /// Clears the value of `coordinates`. Subsequent reads from it will return its default value.
  public mutating func clearCoordinates() {self._coordinates = nil}

  public var pairKey: Data = Data()

  public var validFor: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coordinates: Authentication_CoordinateMessage? = nil
}

public struct Authentication_WebEncryptionKeyResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var coordinates: Authentication_CoordinateMessage {
    get {return _coordinates ?? Authentication_CoordinateMessage()}
    set {_coordinates = newValue}
  }
  /// Returns true if `coordinates` has been explicitly set.
  public var hasCoordinates: Bool {return self._coordinates != nil}
  /// Clears the value of `coordinates`. Subsequent reads from it will return its default value.
  public mutating func clearCoordinates() {self._coordinates = nil}

  public var key: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _coordinates: Authentication_CoordinateMessage? = nil
}

public struct Authentication_ErrorResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 5?
  public var type: Int64 = 0

  public var message: String = String()

  public var `class`: [Authentication_ErrorResponse.ErrorClass] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ErrorClass: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// 2: {1: 1}
    public var `class`: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Authentication_ECDSAKeys: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// idk?
  public var field1: Int64 = 0

  public var encryptedKeys: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Authentication_CurrentDeviceData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var browser: Authentication_Device {
    get {return _browser ?? Authentication_Device()}
    set {_browser = newValue}
  }
  /// Returns true if `browser` has been explicitly set.
  public var hasBrowser: Bool {return self._browser != nil}
  /// Clears the value of `browser`. Subsequent reads from it will return its default value.
  public mutating func clearBrowser() {self._browser = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _browser: Authentication_Device? = nil
}

public struct Authentication_KeyData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mobile: Authentication_Device {
    get {return _mobile ?? Authentication_Device()}
    set {_mobile = newValue}
  }
  /// Returns true if `mobile` has been explicitly set.
  public var hasMobile: Bool {return self._mobile != nil}
  /// Clears the value of `mobile`. Subsequent reads from it will return its default value.
  public mutating func clearMobile() {self._mobile = nil}

  public var ecdsaKeys: Authentication_ECDSAKeys {
    get {return _ecdsaKeys ?? Authentication_ECDSAKeys()}
    set {_ecdsaKeys = newValue}
  }
  /// Returns true if `ecdsaKeys` has been explicitly set.
  public var hasEcdsaKeys: Bool {return self._ecdsaKeys != nil}
  /// Clears the value of `ecdsaKeys`. Subsequent reads from it will return its default value.
  public mutating func clearEcdsaKeys() {self._ecdsaKeys = nil}

  public var webAuthKeyData: Authentication_WebAuthKey {
    get {return _webAuthKeyData ?? Authentication_WebAuthKey()}
    set {_webAuthKeyData = newValue}
  }
  /// Returns true if `webAuthKeyData` has been explicitly set.
  public var hasWebAuthKeyData: Bool {return self._webAuthKeyData != nil}
  /// Clears the value of `webAuthKeyData`. Subsequent reads from it will return its default value.
  public mutating func clearWebAuthKeyData() {self._webAuthKeyData = nil}

  public var browser: Authentication_Device {
    get {return _browser ?? Authentication_Device()}
    set {_browser = newValue}
  }
  /// Returns true if `browser` has been explicitly set.
  public var hasBrowser: Bool {return self._browser != nil}
  /// Clears the value of `browser`. Subsequent reads from it will return its default value.
  public mutating func clearBrowser() {self._browser = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mobile: Authentication_Device? = nil
  fileprivate var _ecdsaKeys: Authentication_ECDSAKeys? = nil
  fileprivate var _webAuthKeyData: Authentication_WebAuthKey? = nil
  fileprivate var _browser: Authentication_Device? = nil
}

public struct Authentication_WebAuthKey: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var webAuthKey: Data = Data()

  public var validFor: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Authentication_URLData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var pairingKey: Data = Data()

  public var aeskey: Data = Data()

  public var hmackey: Data = Data()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Authentication_TokenData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var tachyonAuthToken: Data = Data()

  public var ttl: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Authentication_PairedData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mobile: Authentication_Device {
    get {return _mobile ?? Authentication_Device()}
    set {_mobile = newValue}
  }
  /// Returns true if `mobile` has been explicitly set.
  public var hasMobile: Bool {return self._mobile != nil}
  /// Clears the value of `mobile`. Subsequent reads from it will return its default value.
  public mutating func clearMobile() {self._mobile = nil}

  public var tokenData: Authentication_TokenData {
    get {return _tokenData ?? Authentication_TokenData()}
    set {_tokenData = newValue}
  }
  /// Returns true if `tokenData` has been explicitly set.
  public var hasTokenData: Bool {return self._tokenData != nil}
  /// Clears the value of `tokenData`. Subsequent reads from it will return its default value.
  public mutating func clearTokenData() {self._tokenData = nil}

  public var browser: Authentication_Device {
    get {return _browser ?? Authentication_Device()}
    set {_browser = newValue}
  }
  /// Returns true if `browser` has been explicitly set.
  public var hasBrowser: Bool {return self._browser != nil}
  /// Clears the value of `browser`. Subsequent reads from it will return its default value.
  public mutating func clearBrowser() {self._browser = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _mobile: Authentication_Device? = nil
  fileprivate var _tokenData: Authentication_TokenData? = nil
  fileprivate var _browser: Authentication_Device? = nil
}

public struct Authentication_RevokePairData: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var revokedDevice: Authentication_Device {
    get {return _revokedDevice ?? Authentication_Device()}
    set {_revokedDevice = newValue}
  }
  /// Returns true if `revokedDevice` has been explicitly set.
  public var hasRevokedDevice: Bool {return self._revokedDevice != nil}
  /// Clears the value of `revokedDevice`. Subsequent reads from it will return its default value.
  public mutating func clearRevokedDevice() {self._revokedDevice = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _revokedDevice: Authentication_Device? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "authentication"

extension Authentication_BrowserType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN_BROWSER_TYPE\0\u{1}OTHER\0\u{1}CHROME\0\u{1}FIREFOX\0\u{1}SAFARI\0\u{1}OPERA\0\u{1}IE\0\u{1}EDGE\0")
}

extension Authentication_DeviceType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UNKNOWN_DEVICE_TYPE\0\u{1}WEB\0\u{1}TABLET\0\u{1}PWA\0")
}

extension Authentication_GaiaPairingErrorCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0NONE\0\u{1}UKEY2_ALERT_ERROR\0\u{1}REQUEST_OUT_OF_DATE\0\u{1}REQUEST_NOT_RECEIVED_QUICKLY\0\u{1}INVALID_USER\0\u{1}WRONG_VERIFICATION_CODE_SELECTED\0\u{1}VERIFICATION_TIMED_OUT\0\u{1}USER_CANCELED_VERIFICATION\0\u{1}UKEY2_OTHER_ERROR\0\u{1}VERIFICATION_EMOJI_DOWNLOAD_FAILED\0\u{1}NOT_LATEST_ATTEMPT\0\u{1}VERIFICATION_DATA_SERVICE_NOT_PRESENT\0\u{1}VERIFICATION_INTENTS_NOT_PRESENT\0\u{1}WRONG_UKEY2_MESSAGE_TYPE\0\u{1}REQUEST_COMPLETE_WITH_UNKNOWN_RESULT\0\u{1}PHONE_NOT_AWAITING_CONFIRMATION\0\u{1}UKEY2_MESSAGE_MISSING\0\u{1}CLIENT_INIT_TIMEOUT\0\u{1}CLIENT_FINISHED_TIMEOUT\0\u{1}UNKNOWN\0\u{1}WEB_CANCEL_BUTTON_CLICKED\0\u{1}WEB_BACK_BUTTON_CLICKED\0\u{1}WEB_LEAVE_PAIR_PAGE\0\u{1}NEW_REQUEST_WHILE_WAITING_FOR_VERIFICATION\0\u{1}UKEY2_HANDSHAKE_ERROR\0\u{1}VERIFICATION_CODE_REVISION_MISMATCH\0\u{1}USER_CANCELED_VERIFICATION_ON_WEB\0\u{1}USER_DENIED_VERIFICATION_NOT_ME\0\u{1}KEY_DERIVATION_REVISION_MISMATCH\0\u{1}CMS_BACKUP_KEY_NOT_FOUND\0\u{1}UNABLE_TO_ENCRYPT_CMS_BACKUP_KEY\0\u{1}UNABLE_TO_DECRYPT_CMS_BACKUP_KEY\0")
}

extension Authentication_BrowserDetails: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BrowserDetails"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}userAgent\0\u{1}browserType\0\u{1}OS\0\u{2}\u{3}deviceType\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userAgent) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.browserType) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.os) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.deviceType) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userAgent.isEmpty {
      try visitor.visitSingularStringField(value: self.userAgent, fieldNumber: 1)
    }
    if self.browserType != .unknownBrowserType {
      try visitor.visitSingularEnumField(value: self.browserType, fieldNumber: 2)
    }
    if !self.os.isEmpty {
      try visitor.visitSingularStringField(value: self.os, fieldNumber: 3)
    }
    if self.deviceType != .unknownDeviceType {
      try visitor.visitSingularEnumField(value: self.deviceType, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_BrowserDetails, rhs: Authentication_BrowserDetails) -> Bool {
    if lhs.userAgent != rhs.userAgent {return false}
    if lhs.browserType != rhs.browserType {return false}
    if lhs.os != rhs.os {return false}
    if lhs.deviceType != rhs.deviceType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_Device: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Device"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}userID\0\u{1}sourceID\0\u{1}network\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourceID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.network) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.userID != 0 {
      try visitor.visitSingularInt64Field(value: self.userID, fieldNumber: 1)
    }
    if !self.sourceID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceID, fieldNumber: 2)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_Device, rhs: Authentication_Device) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.sourceID != rhs.sourceID {return false}
    if lhs.network != rhs.network {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_ConfigVersion: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ConfigVersion"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{3}Year\0\u{1}Month\0\u{1}Day\0\u{2}\u{2}V1\0\u{2}\u{2}V2\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.year) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.month) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.day) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.v1) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.v2) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.year != 0 {
      try visitor.visitSingularInt32Field(value: self.year, fieldNumber: 3)
    }
    if self.month != 0 {
      try visitor.visitSingularInt32Field(value: self.month, fieldNumber: 4)
    }
    if self.day != 0 {
      try visitor.visitSingularInt32Field(value: self.day, fieldNumber: 5)
    }
    if self.v1 != 0 {
      try visitor.visitSingularInt32Field(value: self.v1, fieldNumber: 7)
    }
    if self.v2 != 0 {
      try visitor.visitSingularInt32Field(value: self.v2, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_ConfigVersion, rhs: Authentication_ConfigVersion) -> Bool {
    if lhs.year != rhs.year {return false}
    if lhs.month != rhs.month {return false}
    if lhs.day != rhs.day {return false}
    if lhs.v1 != rhs.v1 {return false}
    if lhs.v2 != rhs.v2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_SignInGaiaRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignInGaiaRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}authMessage\0\u{1}inner\0\u{1}unknownInt3\0\u{1}network\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authMessage) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._inner) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.unknownInt3) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.network) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._inner {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.unknownInt3 != 0 {
      try visitor.visitSingularInt32Field(value: self.unknownInt3, fieldNumber: 3)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_SignInGaiaRequest, rhs: Authentication_SignInGaiaRequest) -> Bool {
    if lhs._authMessage != rhs._authMessage {return false}
    if lhs._inner != rhs._inner {return false}
    if lhs.unknownInt3 != rhs.unknownInt3 {return false}
    if lhs.network != rhs.network {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_SignInGaiaRequest.Inner: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_SignInGaiaRequest.protoMessageName + ".Inner"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}deviceID\0\u{2}#someData\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deviceID) }()
      case 36: try { try decoder.decodeSingularMessageField(value: &self._someData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deviceID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._someData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 36)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_SignInGaiaRequest.Inner, rhs: Authentication_SignInGaiaRequest.Inner) -> Bool {
    if lhs._deviceID != rhs._deviceID {return false}
    if lhs._someData != rhs._someData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_SignInGaiaRequest.Inner.DeviceID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_SignInGaiaRequest.Inner.protoMessageName + ".DeviceID"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}unknownInt1\0\u{1}deviceID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.unknownInt1) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unknownInt1 != 0 {
      try visitor.visitSingularInt32Field(value: self.unknownInt1, fieldNumber: 1)
    }
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_SignInGaiaRequest.Inner.DeviceID, rhs: Authentication_SignInGaiaRequest.Inner.DeviceID) -> Bool {
    if lhs.unknownInt1 != rhs.unknownInt1 {return false}
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_SignInGaiaRequest.Inner.DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_SignInGaiaRequest.Inner.protoMessageName + ".Data"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{3}someData\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 3: try { try decoder.decodeSingularBytesField(value: &self.someData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.someData.isEmpty {
      try visitor.visitSingularBytesField(value: self.someData, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_SignInGaiaRequest.Inner.DataMessage, rhs: Authentication_SignInGaiaRequest.Inner.DataMessage) -> Bool {
    if lhs.someData != rhs.someData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_SignInGaiaResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".SignInGaiaResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}header\0\u{1}maybeBrowserUUID\0\u{1}deviceData\0\u{1}tokenData\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._header) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.maybeBrowserUuid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._deviceData) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._tokenData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._header {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.maybeBrowserUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.maybeBrowserUuid, fieldNumber: 2)
    }
    try { if let v = self._deviceData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._tokenData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_SignInGaiaResponse, rhs: Authentication_SignInGaiaResponse) -> Bool {
    if lhs._header != rhs._header {return false}
    if lhs.maybeBrowserUuid != rhs.maybeBrowserUuid {return false}
    if lhs._deviceData != rhs._deviceData {return false}
    if lhs._tokenData != rhs._tokenData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_SignInGaiaResponse.Header: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_SignInGaiaResponse.protoMessageName + ".Header"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}unknownInt2\0\u{2}\u{2}unknownTimestamp\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.unknownInt2) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.unknownTimestamp) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unknownInt2 != 0 {
      try visitor.visitSingularUInt64Field(value: self.unknownInt2, fieldNumber: 2)
    }
    if self.unknownTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.unknownTimestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_SignInGaiaResponse.Header, rhs: Authentication_SignInGaiaResponse.Header) -> Bool {
    if lhs.unknownInt2 != rhs.unknownInt2 {return false}
    if lhs.unknownTimestamp != rhs.unknownTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_SignInGaiaResponse.DeviceData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_SignInGaiaResponse.protoMessageName + ".DeviceData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}deviceWrapper\0\u{1}unknownItems2\0\u{1}unknownItems3\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._deviceWrapper) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.unknownItems2) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.unknownItems3) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._deviceWrapper {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.unknownItems2.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unknownItems2, fieldNumber: 2)
    }
    if !self.unknownItems3.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.unknownItems3, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_SignInGaiaResponse.DeviceData, rhs: Authentication_SignInGaiaResponse.DeviceData) -> Bool {
    if lhs._deviceWrapper != rhs._deviceWrapper {return false}
    if lhs.unknownItems2 != rhs.unknownItems2 {return false}
    if lhs.unknownItems3 != rhs.unknownItems3 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_SignInGaiaResponse.DeviceData.DeviceWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_SignInGaiaResponse.DeviceData.protoMessageName + ".DeviceWrapper"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}device\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_SignInGaiaResponse.DeviceData.DeviceWrapper, rhs: Authentication_SignInGaiaResponse.DeviceData.DeviceWrapper) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_GaiaPairingRequestContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GaiaPairingRequestContainer"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}pairingAttemptID\0\u{1}browserDetails\0\u{1}startTimestamp\0\u{1}data\0\u{1}proposedVerificationCodeVersion\0\u{1}proposedKeyDerivationVersion\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pairingAttemptID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._browserDetails) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.startTimestamp) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.proposedVerificationCodeVersion) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.proposedKeyDerivationVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pairingAttemptID.isEmpty {
      try visitor.visitSingularStringField(value: self.pairingAttemptID, fieldNumber: 1)
    }
    try { if let v = self._browserDetails {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.startTimestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.startTimestamp, fieldNumber: 3)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 4)
    }
    if self.proposedVerificationCodeVersion != 0 {
      try visitor.visitSingularInt32Field(value: self.proposedVerificationCodeVersion, fieldNumber: 5)
    }
    if self.proposedKeyDerivationVersion != 0 {
      try visitor.visitSingularInt32Field(value: self.proposedKeyDerivationVersion, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_GaiaPairingRequestContainer, rhs: Authentication_GaiaPairingRequestContainer) -> Bool {
    if lhs.pairingAttemptID != rhs.pairingAttemptID {return false}
    if lhs._browserDetails != rhs._browserDetails {return false}
    if lhs.startTimestamp != rhs.startTimestamp {return false}
    if lhs.data != rhs.data {return false}
    if lhs.proposedVerificationCodeVersion != rhs.proposedVerificationCodeVersion {return false}
    if lhs.proposedKeyDerivationVersion != rhs.proposedKeyDerivationVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_GaiaPairingResponseContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GaiaPairingResponseContainer"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}finishErrorType\0\u{1}finishErrorCode\0\u{1}unknownInt3\0\u{1}sessionUUID\0\u{1}data\0\u{1}confirmedVerificationCodeVersion\0\u{1}confirmedKeyDerivationVersion\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.finishErrorType) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.finishErrorCode) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.unknownInt3) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sessionUuid) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.confirmedVerificationCodeVersion) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.confirmedKeyDerivationVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.finishErrorType != 0 {
      try visitor.visitSingularInt32Field(value: self.finishErrorType, fieldNumber: 1)
    }
    if self.finishErrorCode != .none {
      try visitor.visitSingularEnumField(value: self.finishErrorCode, fieldNumber: 2)
    }
    if self.unknownInt3 != 0 {
      try visitor.visitSingularInt32Field(value: self.unknownInt3, fieldNumber: 3)
    }
    if !self.sessionUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionUuid, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 5)
    }
    if self.confirmedVerificationCodeVersion != 0 {
      try visitor.visitSingularInt32Field(value: self.confirmedVerificationCodeVersion, fieldNumber: 6)
    }
    if self.confirmedKeyDerivationVersion != 0 {
      try visitor.visitSingularInt32Field(value: self.confirmedKeyDerivationVersion, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_GaiaPairingResponseContainer, rhs: Authentication_GaiaPairingResponseContainer) -> Bool {
    if lhs.finishErrorType != rhs.finishErrorType {return false}
    if lhs.finishErrorCode != rhs.finishErrorCode {return false}
    if lhs.unknownInt3 != rhs.unknownInt3 {return false}
    if lhs.sessionUuid != rhs.sessionUuid {return false}
    if lhs.data != rhs.data {return false}
    if lhs.confirmedVerificationCodeVersion != rhs.confirmedVerificationCodeVersion {return false}
    if lhs.confirmedKeyDerivationVersion != rhs.confirmedKeyDerivationVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RevokeGaiaPairingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeGaiaPairingRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}pairingAttemptID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pairingAttemptID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pairingAttemptID.isEmpty {
      try visitor.visitSingularStringField(value: self.pairingAttemptID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RevokeGaiaPairingRequest, rhs: Authentication_RevokeGaiaPairingRequest) -> Bool {
    if lhs.pairingAttemptID != rhs.pairingAttemptID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RPCGaiaData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RPCGaiaData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}command\0\u{2}k\u{1}maybeServerData\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.command) }()
      case 108: try { try decoder.decodeSingularMessageField(value: &self._maybeServerData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.command != 0 {
      try visitor.visitSingularInt32Field(value: self.command, fieldNumber: 1)
    }
    try { if let v = self._maybeServerData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 108)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RPCGaiaData, rhs: Authentication_RPCGaiaData) -> Bool {
    if lhs.command != rhs.command {return false}
    if lhs._maybeServerData != rhs._maybeServerData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RPCGaiaData.UnknownContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_RPCGaiaData.protoMessageName + ".UnknownContainer"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}item2\0\u{1}unknownTimestampMicroseconds\0\u{1}item4\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._item2) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.unknownTimestampMicroseconds) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.item4) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._item2 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.unknownTimestampMicroseconds != 0 {
      try visitor.visitSingularInt64Field(value: self.unknownTimestampMicroseconds, fieldNumber: 3)
    }
    if !self.item4.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.item4, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RPCGaiaData.UnknownContainer, rhs: Authentication_RPCGaiaData.UnknownContainer) -> Bool {
    if lhs._item2 != rhs._item2 {return false}
    if lhs.unknownTimestampMicroseconds != rhs.unknownTimestampMicroseconds {return false}
    if lhs.item4 != rhs.item4 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RPCGaiaData.UnknownContainer.Item2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_RPCGaiaData.UnknownContainer.protoMessageName + ".Item2"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}item1\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.item1) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.item1.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.item1, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RPCGaiaData.UnknownContainer.Item2, rhs: Authentication_RPCGaiaData.UnknownContainer.Item2) -> Bool {
    if lhs.item1 != rhs.item1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RPCGaiaData.UnknownContainer.Item2.Item1: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_RPCGaiaData.UnknownContainer.Item2.protoMessageName + ".Item1"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}destOrSourceUUID\0\u{2}\u{3}unknownInt4\0\u{1}languageCode\0\u{2}\u{2}unknownBigInt7\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.destOrSourceUuid) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.unknownInt4) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.languageCode) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.unknownBigInt7) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.destOrSourceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.destOrSourceUuid, fieldNumber: 1)
    }
    if self.unknownInt4 != 0 {
      try visitor.visitSingularInt32Field(value: self.unknownInt4, fieldNumber: 4)
    }
    if !self.languageCode.isEmpty {
      try visitor.visitSingularStringField(value: self.languageCode, fieldNumber: 5)
    }
    if self.unknownBigInt7 != 0 {
      try visitor.visitSingularUInt64Field(value: self.unknownBigInt7, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RPCGaiaData.UnknownContainer.Item2.Item1, rhs: Authentication_RPCGaiaData.UnknownContainer.Item2.Item1) -> Bool {
    if lhs.destOrSourceUuid != rhs.destOrSourceUuid {return false}
    if lhs.unknownInt4 != rhs.unknownInt4 {return false}
    if lhs.languageCode != rhs.languageCode {return false}
    if lhs.unknownBigInt7 != rhs.unknownBigInt7 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RPCGaiaData.UnknownContainer.Item4: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_RPCGaiaData.UnknownContainer.protoMessageName + ".Item4"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}destOrSourceUUID\0\u{2}\u{2}unknownInt3\0\u{1}unknownInt4\0\u{2}\u{3}unknownTimestampMicroseconds\0\u{1}item8\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.destOrSourceUuid) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.unknownInt3) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.unknownInt4) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.unknownTimestampMicroseconds) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._item8) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.destOrSourceUuid.isEmpty {
      try visitor.visitSingularStringField(value: self.destOrSourceUuid, fieldNumber: 1)
    }
    if self.unknownInt3 != 0 {
      try visitor.visitSingularInt32Field(value: self.unknownInt3, fieldNumber: 3)
    }
    if self.unknownInt4 != 0 {
      try visitor.visitSingularInt32Field(value: self.unknownInt4, fieldNumber: 4)
    }
    if self.unknownTimestampMicroseconds != 0 {
      try visitor.visitSingularInt64Field(value: self.unknownTimestampMicroseconds, fieldNumber: 7)
    }
    try { if let v = self._item8 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RPCGaiaData.UnknownContainer.Item4, rhs: Authentication_RPCGaiaData.UnknownContainer.Item4) -> Bool {
    if lhs.destOrSourceUuid != rhs.destOrSourceUuid {return false}
    if lhs.unknownInt3 != rhs.unknownInt3 {return false}
    if lhs.unknownInt4 != rhs.unknownInt4 {return false}
    if lhs.unknownTimestampMicroseconds != rhs.unknownTimestampMicroseconds {return false}
    if lhs._item8 != rhs._item8 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RPCGaiaData.UnknownContainer.Item4.Item8: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_RPCGaiaData.UnknownContainer.Item4.protoMessageName + ".Item8"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}unknownInt1\0\u{1}unknownTimestamp\0\u{1}unknownBytes\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.unknownInt1) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.unknownTimestamp) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.unknownBytes) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.unknownInt1 != 0 {
      try visitor.visitSingularInt32Field(value: self.unknownInt1, fieldNumber: 1)
    }
    if self.unknownTimestamp != 0 {
      try visitor.visitSingularInt32Field(value: self.unknownTimestamp, fieldNumber: 2)
    }
    if !self.unknownBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.unknownBytes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RPCGaiaData.UnknownContainer.Item4.Item8, rhs: Authentication_RPCGaiaData.UnknownContainer.Item4.Item8) -> Bool {
    if lhs.unknownInt1 != rhs.unknownInt1 {return false}
    if lhs.unknownTimestamp != rhs.unknownTimestamp {return false}
    if lhs.unknownBytes != rhs.unknownBytes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_AuthenticationContainer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthenticationContainer"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}authMessage\0\u{2}\u{2}browserDetails\0\u{1}keyData\0\u{1}deviceData\0")

  fileprivate class _StorageClass {
    var _authMessage: Authentication_AuthMessage? = nil
    var _browserDetails: Authentication_BrowserDetails? = nil
    var _data: Authentication_AuthenticationContainer.OneOf_Data?

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _authMessage = source._authMessage
      _browserDetails = source._browserDetails
      _data = source._data
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._authMessage) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._browserDetails) }()
        case 4: try {
          var v: Authentication_KeyData?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .keyData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .keyData(v)
          }
        }()
        case 5: try {
          var v: Authentication_CurrentDeviceData?
          var hadOneofValue = false
          if let current = _storage._data {
            hadOneofValue = true
            if case .deviceData(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._data = .deviceData(v)
          }
        }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._authMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._browserDetails {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      switch _storage._data {
      case .keyData?: try {
        guard case .keyData(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .deviceData?: try {
        guard case .deviceData(let v)? = _storage._data else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_AuthenticationContainer, rhs: Authentication_AuthenticationContainer) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._authMessage != rhs_storage._authMessage {return false}
        if _storage._browserDetails != rhs_storage._browserDetails {return false}
        if _storage._data != rhs_storage._data {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_AuthMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AuthMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}requestID\0\u{2}\u{2}network\0\u{2}\u{3}tachyonAuthToken\0\u{1}configVersion\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.requestID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.network) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.tachyonAuthToken) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._configVersion) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.requestID.isEmpty {
      try visitor.visitSingularStringField(value: self.requestID, fieldNumber: 1)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 3)
    }
    if !self.tachyonAuthToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.tachyonAuthToken, fieldNumber: 6)
    }
    try { if let v = self._configVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_AuthMessage, rhs: Authentication_AuthMessage) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.network != rhs.network {return false}
    if lhs.tachyonAuthToken != rhs.tachyonAuthToken {return false}
    if lhs._configVersion != rhs._configVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RevokeRelayPairingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeRelayPairingRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}authMessage\0\u{1}browser\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._authMessage) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._browser) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._authMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._browser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RevokeRelayPairingRequest, rhs: Authentication_RevokeRelayPairingRequest) -> Bool {
    if lhs._authMessage != rhs._authMessage {return false}
    if lhs._browser != rhs._browser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RevokeRelayPairingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokeRelayPairingResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RevokeRelayPairingResponse, rhs: Authentication_RevokeRelayPairingResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RegisterRefreshRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterRefreshRequest"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}messageAuth\0\u{1}currBrowserDevice\0\u{1}unixTimestamp\0\u{1}signature\0\u{2}\u{9}parameters\0\u{2}\u{3}messageType\0")

  fileprivate class _StorageClass {
    var _messageAuth: Authentication_AuthMessage? = nil
    var _currBrowserDevice: Authentication_Device? = nil
    var _unixTimestamp: Int64 = 0
    var _signature: Data = Data()
    var _parameters: Authentication_RegisterRefreshRequest.Parameters? = nil
    var _messageType: Int32 = 0

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _messageAuth = source._messageAuth
      _currBrowserDevice = source._currBrowserDevice
      _unixTimestamp = source._unixTimestamp
      _signature = source._signature
      _parameters = source._parameters
      _messageType = source._messageType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._messageAuth) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._currBrowserDevice) }()
        case 3: try { try decoder.decodeSingularInt64Field(value: &_storage._unixTimestamp) }()
        case 4: try { try decoder.decodeSingularBytesField(value: &_storage._signature) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._parameters) }()
        case 16: try { try decoder.decodeSingularInt32Field(value: &_storage._messageType) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._messageAuth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._currBrowserDevice {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if _storage._unixTimestamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unixTimestamp, fieldNumber: 3)
      }
      if !_storage._signature.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._signature, fieldNumber: 4)
      }
      try { if let v = _storage._parameters {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      if _storage._messageType != 0 {
        try visitor.visitSingularInt32Field(value: _storage._messageType, fieldNumber: 16)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RegisterRefreshRequest, rhs: Authentication_RegisterRefreshRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._messageAuth != rhs_storage._messageAuth {return false}
        if _storage._currBrowserDevice != rhs_storage._currBrowserDevice {return false}
        if _storage._unixTimestamp != rhs_storage._unixTimestamp {return false}
        if _storage._signature != rhs_storage._signature {return false}
        if _storage._parameters != rhs_storage._parameters {return false}
        if _storage._messageType != rhs_storage._messageType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RegisterRefreshRequest.PushRegistration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_RegisterRefreshRequest.protoMessageName + ".PushRegistration"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}url\0\u{1}p256dh\0\u{1}auth\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.p256Dh) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.auth) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 2)
    }
    if !self.p256Dh.isEmpty {
      try visitor.visitSingularStringField(value: self.p256Dh, fieldNumber: 3)
    }
    if !self.auth.isEmpty {
      try visitor.visitSingularStringField(value: self.auth, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RegisterRefreshRequest.PushRegistration, rhs: Authentication_RegisterRefreshRequest.PushRegistration) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.url != rhs.url {return false}
    if lhs.p256Dh != rhs.p256Dh {return false}
    if lhs.auth != rhs.auth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RegisterRefreshRequest.MoreParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_RegisterRefreshRequest.protoMessageName + ".MoreParameters"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}three\0\u{2}e\u{1}pushReg\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.three) }()
      case 102: try { try decoder.decodeSingularMessageField(value: &self._pushReg) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.three != 0 {
      try visitor.visitSingularInt32Field(value: self.three, fieldNumber: 1)
    }
    try { if let v = self._pushReg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RegisterRefreshRequest.MoreParameters, rhs: Authentication_RegisterRefreshRequest.MoreParameters) -> Bool {
    if lhs.three != rhs.three {return false}
    if lhs._pushReg != rhs._pushReg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RegisterRefreshRequest.Parameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_RegisterRefreshRequest.protoMessageName + ".Parameters"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{9}emptyArr\0\u{2}\u{e}moreParameters\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 9: try { try decoder.decodeSingularMessageField(value: &self._emptyArr) }()
      case 23: try { try decoder.decodeSingularMessageField(value: &self._moreParameters) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._emptyArr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._moreParameters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RegisterRefreshRequest.Parameters, rhs: Authentication_RegisterRefreshRequest.Parameters) -> Bool {
    if lhs._emptyArr != rhs._emptyArr {return false}
    if lhs._moreParameters != rhs._moreParameters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RegisterRefreshResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterRefreshResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}tokenData\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tokenData) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tokenData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RegisterRefreshResponse, rhs: Authentication_RegisterRefreshResponse) -> Bool {
    if lhs._tokenData != rhs._tokenData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RegisterPhoneRelayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RegisterPhoneRelayResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}coordinates\0\u{1}browser\0\u{1}pairingKey\0\u{1}validFor\0\u{1}authKeyData\0\u{1}responseID\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coordinates) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._browser) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.pairingKey) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.validFor) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._authKeyData) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.responseID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coordinates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._browser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.pairingKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pairingKey, fieldNumber: 3)
    }
    if self.validFor != 0 {
      try visitor.visitSingularInt64Field(value: self.validFor, fieldNumber: 4)
    }
    try { if let v = self._authKeyData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.responseID.isEmpty {
      try visitor.visitSingularStringField(value: self.responseID, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RegisterPhoneRelayResponse, rhs: Authentication_RegisterPhoneRelayResponse) -> Bool {
    if lhs._coordinates != rhs._coordinates {return false}
    if lhs._browser != rhs._browser {return false}
    if lhs.pairingKey != rhs.pairingKey {return false}
    if lhs.validFor != rhs.validFor {return false}
    if lhs._authKeyData != rhs._authKeyData {return false}
    if lhs.responseID != rhs.responseID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_CoordinateMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CoordinateMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\u{2}coord1\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.coord1) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.coord1 != 0 {
      try visitor.visitSingularInt64Field(value: self.coord1, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_CoordinateMessage, rhs: Authentication_CoordinateMessage) -> Bool {
    if lhs.coord1 != rhs.coord1 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RefreshPhoneRelayResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RefreshPhoneRelayResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}coordinates\0\u{1}pairKey\0\u{1}validFor\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coordinates) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.pairKey) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.validFor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coordinates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.pairKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pairKey, fieldNumber: 2)
    }
    if self.validFor != 0 {
      try visitor.visitSingularInt64Field(value: self.validFor, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RefreshPhoneRelayResponse, rhs: Authentication_RefreshPhoneRelayResponse) -> Bool {
    if lhs._coordinates != rhs._coordinates {return false}
    if lhs.pairKey != rhs.pairKey {return false}
    if lhs.validFor != rhs.validFor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_WebEncryptionKeyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebEncryptionKeyResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}coordinates\0\u{1}key\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._coordinates) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.key) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._coordinates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_WebEncryptionKeyResponse, rhs: Authentication_WebEncryptionKeyResponse) -> Bool {
    if lhs._coordinates != rhs._coordinates {return false}
    if lhs.key != rhs.key {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_ErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorResponse"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}message\0\u{1}class\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.`class`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != 0 {
      try visitor.visitSingularInt64Field(value: self.type, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if !self.`class`.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.`class`, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_ErrorResponse, rhs: Authentication_ErrorResponse) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.message != rhs.message {return false}
    if lhs.`class` != rhs.`class` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_ErrorResponse.ErrorClass: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Authentication_ErrorResponse.protoMessageName + ".ErrorClass"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}class\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.`class`) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.`class`.isEmpty {
      try visitor.visitSingularStringField(value: self.`class`, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_ErrorResponse.ErrorClass, rhs: Authentication_ErrorResponse.ErrorClass) -> Bool {
    if lhs.`class` != rhs.`class` {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_ECDSAKeys: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ECDSAKeys"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}field1\0\u{1}encryptedKeys\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.field1) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.encryptedKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.field1 != 0 {
      try visitor.visitSingularInt64Field(value: self.field1, fieldNumber: 1)
    }
    if !self.encryptedKeys.isEmpty {
      try visitor.visitSingularBytesField(value: self.encryptedKeys, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_ECDSAKeys, rhs: Authentication_ECDSAKeys) -> Bool {
    if lhs.field1 != rhs.field1 {return false}
    if lhs.encryptedKeys != rhs.encryptedKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_CurrentDeviceData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CurrentDeviceData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}browser\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._browser) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._browser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_CurrentDeviceData, rhs: Authentication_CurrentDeviceData) -> Bool {
    if lhs._browser != rhs._browser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_KeyData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".KeyData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mobile\0\u{1}webAuthKeyData\0\u{1}browser\0\u{2}\u{3}ecdsaKeys\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mobile) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._webAuthKeyData) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._browser) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._ecdsaKeys) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mobile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._webAuthKeyData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._browser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ecdsaKeys {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_KeyData, rhs: Authentication_KeyData) -> Bool {
    if lhs._mobile != rhs._mobile {return false}
    if lhs._ecdsaKeys != rhs._ecdsaKeys {return false}
    if lhs._webAuthKeyData != rhs._webAuthKeyData {return false}
    if lhs._browser != rhs._browser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_WebAuthKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".WebAuthKey"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}webAuthKey\0\u{1}validFor\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.webAuthKey) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.validFor) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.webAuthKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.webAuthKey, fieldNumber: 1)
    }
    if self.validFor != 0 {
      try visitor.visitSingularInt64Field(value: self.validFor, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_WebAuthKey, rhs: Authentication_WebAuthKey) -> Bool {
    if lhs.webAuthKey != rhs.webAuthKey {return false}
    if lhs.validFor != rhs.validFor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_URLData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".URLData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}pairingKey\0\u{1}AESKey\0\u{1}HMACKey\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pairingKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.aeskey) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.hmackey) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pairingKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pairingKey, fieldNumber: 1)
    }
    if !self.aeskey.isEmpty {
      try visitor.visitSingularBytesField(value: self.aeskey, fieldNumber: 2)
    }
    if !self.hmackey.isEmpty {
      try visitor.visitSingularBytesField(value: self.hmackey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_URLData, rhs: Authentication_URLData) -> Bool {
    if lhs.pairingKey != rhs.pairingKey {return false}
    if lhs.aeskey != rhs.aeskey {return false}
    if lhs.hmackey != rhs.hmackey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_TokenData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TokenData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}tachyonAuthToken\0\u{1}TTL\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.tachyonAuthToken) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.ttl) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.tachyonAuthToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.tachyonAuthToken, fieldNumber: 1)
    }
    if self.ttl != 0 {
      try visitor.visitSingularInt64Field(value: self.ttl, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_TokenData, rhs: Authentication_TokenData) -> Bool {
    if lhs.tachyonAuthToken != rhs.tachyonAuthToken {return false}
    if lhs.ttl != rhs.ttl {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_PairedData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PairedData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mobile\0\u{1}tokenData\0\u{1}browser\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._mobile) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._tokenData) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._browser) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mobile {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tokenData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._browser {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_PairedData, rhs: Authentication_PairedData) -> Bool {
    if lhs._mobile != rhs._mobile {return false}
    if lhs._tokenData != rhs._tokenData {return false}
    if lhs._browser != rhs._browser {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Authentication_RevokePairData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".RevokePairData"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}revokedDevice\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._revokedDevice) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._revokedDevice {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Authentication_RevokePairData, rhs: Authentication_RevokePairData) -> Bool {
    if lhs._revokedDevice != rhs._revokedDevice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
